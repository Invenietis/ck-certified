<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CK.Core</name>
    </assembly>
    <members>
        <member name="T:CK.Core.EnumMono`1">
            <summary>
            Defines an optimized <see cref="T:System.Collections.Generic.IEnumerator`1"/> that contains
            only one element.
            </summary>
        </member>
        <member name="M:CK.Core.EnumMono`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="val">Unique object that will be contained into the <see cref="T:CK.Core.EnumMono`1"/></param>
        </member>
        <member name="M:CK.Core.EnumMono`1.Dispose">
            <summary>
            Dispose the <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.EnumMono`1.MoveNext">
            <summary>
            Move to the next element.
            </summary>
            <returns>True if position is equal to 0, false otherwise</returns>
        </member>
        <member name="M:CK.Core.EnumMono`1.Reset">
            <summary>
            Reset the enumerator.
            </summary>
        </member>
        <member name="P:CK.Core.EnumMono`1.Current">
            <summary>
            Gets the strongly typed element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="T:CK.Core.ISimpleTypeNaming">
            <summary>
            This simple interface allows to obtain names from types.
            This can be used in conjuction with <see cref="T:CK.Core.ISimpleTypeFinder"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ISimpleTypeNaming.GetTypeName(System.Type)">
            <summary>
            Gets an external type name.
            </summary>
            <param name="t">The type for which an external type name must be obtained.</param>
            <returns>
            A string that represents the given type. 
            Can default to <see cref="P:System.Type.AssemblyQualifiedName"/>.
            </returns>
        </member>
        <member name="T:CK.Core.IReadOnlyUniqueKeyedCollection`2">
            <summary>
            Represents a generic read only keyed collections of covariant items with
            a contravariant key. This interface can be supported by collections that 
            support duplicated items.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <typeparam name="TKey">The type of the key associated to the elements.</typeparam>
        </member>
        <member name="T:CK.Core.IReadOnlyCollection`1">
            <summary>
            Represents a generic read only collections of objects.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
        </member>
        <member name="M:CK.Core.IReadOnlyCollection`1.Contains(System.Object)">
            <summary>
            Determines whether collection contains a specific value.
            </summary>
            <param name="item">The object to find in the collecion.</param>
            <returns>True if item is found in the collection; otherwise, false.</returns>
        </member>
        <member name="P:CK.Core.IReadOnlyCollection`1.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
        </member>
        <member name="M:CK.Core.IReadOnlyUniqueKeyedCollection`2.Contains(`1)">
            <summary>
            Checks whether any item in this keyed collection is associated to the
            given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>True if the key exists, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.IReadOnlyUniqueKeyedCollection`2.GetByKey(`1,System.Boolean@)">
            <summary>
            Gets the item with the associated key.
            When duplicated item exists, any item with the given key can be returned.
            </summary>
            <param name="key">The item key.</param>
            <param name="exists">True if the key has been found, false otherwise (see remarks).</param>
            <returns>The item that matches the key, default(T) if the key can not be found.</returns>
            <remarks>
            Due to current CLI limitation (out parameters are actually ref parameters), it is not possible 
            to define a method with an ( out T ) parameter where T is covariant: we can not define 
            the standard TryGetValue method but this "opposite" form.
            </remarks>
        </member>
        <member name="T:CK.Core.IActivityLogger">
            <summary>
            Simple activity logger for end user communication. This is not the same as a classical logging framework: this 
            is dedicated to capture activities in order to display it to a end user.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityLogger.UnfilteredLog(CK.Core.LogLevel,System.String)">
            <summary>
            Logs a text regardless of <see cref="P:CK.Core.IActivityLogger.Filter"/> level. 
            Each call to log is considered as a line: a paragraph (or line separator) is appended
            between each text if the <paramref name="level"/> is the same as the previous one.
            See remarks.
            </summary>
            <param name="level">Log level.</param>
            <param name="text">Text to log.</param>
            <returns>This logger to enable fluent syntax.</returns>
            <remarks>
            A null <paramref name="text"/> is not logged in itself but instead breaks the current <see cref="T:CK.Core.LogLevel"/>
            (as if a different <see cref="T:CK.Core.LogLevel"/> was used).
            </remarks>
        </member>
        <member name="M:CK.Core.IActivityLogger.OpenGroup(CK.Core.LogLevel,System.Func{System.String},System.String)">
            <summary>
            Opens a log level. <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)"/> must be called in order to
            close the group, or the returned object must be disposed.
            </summary>
            <param name="level">Log level. Since we are opening a group, the current <see cref="P:CK.Core.IActivityLogger.Filter"/> is ignored.</param>
            <param name="text">Text to log (the title of the group).</param>
            <param name="getConclusionText">Optional function that will be called on group closing.</param>
            <returns>A disposable object that can be used to close the group.</returns>
            <remarks>
            A group opening is not filtered since any subordinated logs may occur with a much higher level.
            It is left to the implementation to handle (or not) filtering when <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)"/> is called.
            </remarks>
        </member>
        <member name="M:CK.Core.IActivityLogger.CloseGroup(System.String)">
            <summary>
            Closes the current group level, appending an optional conclusion to the opening logged information.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogger.Filter">
            <summary>
            Gets or sets a filter based on the log level.
            This filter applies to the currently opened group.
            </summary>
        </member>
        <member name="T:CK.Core.OSVersionInfo">
            <summary>
            Provides detailed information about the host operating system.
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.RunningDirectory">
            <summary>
            This is equal to <c>Path.GetDirectoryName( System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName )</c>.
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.IsMono">
            <summary>
            True if we are running Mono.
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.IsUnix">
            <summary>
            True if we are running on Unix.
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.PInvokeSupported">
            <summary>
            True if Platform Invoke is supported.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.ProgramBits">
            <summary>
            Determines if the current application is 32 or 64-bit.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.OSBits">
            <summary>
            Gets the <see cref="T:CK.Core.OSVersionInfo.SoftwareArchitecture"/> of the application.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.ProcessorBits">
            <summary>
            Determines if the current processor is 32 or 64-bit.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.Edition">
            <summary>
            Gets the edition of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.Name">
            <summary>
            Gets the name of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.ServicePack">
            <summary>
            Gets the service pack information of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.IsWindowsVistaOrGreater">
            <summary>
            Gets if the OS is Windows Vista or greater (like Windows 7).
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.BuildVersion">
            <summary>
            Gets the build version number of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.VersionString">
            <summary>
            Gets the full version string of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.Version">
            <summary>
            Gets the full version of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.MajorVersion">
            <summary>
            Gets the major version number of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.MinorVersion">
            <summary>
            Gets the minor version number of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.RevisionVersion">
            <summary>
            Gets the revision version number of the operating system running on this computer.
            </summary>
        </member>
        <member name="T:CK.Core.OSVersionInfo.SoftwareArchitecture">
            <summary>
            Underlying achitecture of the software
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.SoftwareArchitecture.Unknown">
            <summary>
            Unkown
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.SoftwareArchitecture.Bit32">
            <summary>
            32 bits
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.SoftwareArchitecture.Bit64">
            <summary>
            64 bits
            </summary>
        </member>
        <member name="T:CK.Core.OSVersionInfo.ProcessorArchitecture">
            <summary>
            Underlying achitecture of the hardware
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.ProcessorArchitecture.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.ProcessorArchitecture.Bit32">
            <summary>
            32 bits
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.ProcessorArchitecture.Bit64">
            <summary>
            64 bits
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.ProcessorArchitecture.Itanium64">
            <summary>
            Itanium
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyListEmpty`1">
            <summary>
            Empty read only list.
            </summary>
            <typeparam name="T">Contained elements type.</typeparam>
        </member>
        <member name="T:CK.Core.IReadOnlyList`1">
            <summary>
            Represents a read only collection of objects that can be individually accessed by index.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:CK.Core.IReadOnlyList`1.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the list.
            </summary>
            <param name="item">The object to locate in the list.</param>
            <returns>
            A positive index of the item in this list, if found, a negative index otherwise.
            If this list is sorted, this must work exactly like <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: if the item is not found and could be added, the result 
            is a negative number which is the bitwise complement of the index at which the new item should be inserted.
            To handle the case where the item can NOT be inserted and to be consistent with the positive/negative index semantics, the <see cref="F:System.Int32.MinValue"/>
            must be returned. See remarks.
            </returns>
            <remarks>
            <para>
            The fact that <see cref="F:System.Int32.MinValue"/> is used to indicate an "impossible index" enables this covariant list to gracefully handle 
            the case where the item's type is more general that the actual type list.
            </para>
            <para>
            Similarly, if the implementation is associated to any kind of filters, returning <see cref="F:System.Int32.MinValue"/> instead of any other negative value
            indicates to the caller that the item does not appear in the list, but more than that, that it CAN NOT appear.
            </para>
            <para>
            Note that an implementation can perfectly ignore these guidelines and returns -1 (typically) for any unexisting items: it is not an obligation
            to challenge any possible filters or constraints inside this IndexOf method.
            </para>
            <para>
            On the other hand, if this method returns <see cref="F:System.Int32.MinValue"/> then it MUST mean that the item can NOT appear in this list.
            </para>
            </remarks>
        </member>
        <member name="P:CK.Core.IReadOnlyList`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index"/> is not a valid index in the list.</exception>
        </member>
        <member name="F:CK.Core.ReadOnlyListEmpty`1.Empty">
            <summary>
            Static empty <see cref="T:CK.Core.ReadOnlyListEmpty`1"/>
            that will be used by the entire system.
            </summary>
        </member>
        <member name="M:CK.Core.ReadOnlyListEmpty`1.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:CK.Core.ReadOnlyListEmpty`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the given element into the list.
            </summary>
            <param name="item">Element to find in the list</param>
            <returns>Index of the given element</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListEmpty`1.Contains(System.Object)">
            <summary>
            Gets if the given element is contained into the list.
            </summary>
            <param name="item">Element to find</param>
            <returns>False in all cases, a <see cref="T:CK.Core.ReadOnlyListEmpty`1"/> doesn't contains any elements.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListEmpty`1.GetEnumerator">
            <summary>
            Gets the underlying enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListEmpty`1.Item(System.Int32)">
            <summary>
            Gets an element at the given index.
            </summary>
            <param name="i">index of the element to find</param>
            <returns>New <see cref="T:System.IndexOutOfRangeException"/>. 
            Because a <see cref="T:CK.Core.ReadOnlyListEmpty`1"/> doesn't contains any elements.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListEmpty`1.Count">
            <summary>
            Gets the count of the list.
            It will be 0 in all cases.
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyCollectionOnICollection`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.ICollection`1"/> object to the <see cref="T:CK.Core.IReadOnlyCollection`1"/> interface.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnICollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionOnICollection`1"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnICollection`1.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnICollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionOnICollection`1.Inner">
            <summary>
            Gets or sets the wrapped collection.
            </summary>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionOnICollection`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.IUniqueId"/> interface.
            </summary>
        </member>
        <member name="T:CK.Core.IUniqueId">
            <summary>
            Minimal interface that enables any type (specially reference type) to
            expose a <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="P:CK.Core.IUniqueId.UniqueId">
            <summary>
            Gets the unique identifier associated to this object.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.IUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.IUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a marker.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.EmptyArray">
            <summary>
            Empty array of <see cref="T:CK.Core.IUniqueId"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleUniqueId.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleUniqueId"/> where its <see cref="P:CK.Core.SimpleUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
        </member>
        <member name="M:CK.Core.SimpleUniqueId.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleUniqueId"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleUniqueId.UniqueId"/>.</param>
        </member>
        <member name="P:CK.Core.SimpleUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="T:CK.Core.TemporaryFile">
            <summary>
            Small helper to automatically delete a temporary file. 
            It is mainly a secure wrapper around <see cref="M:System.IO.Path.GetTempFileName">GetTempFileName</see> that 
            creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file: the <see cref="P:Path"/>
            property exposes it.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/>.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.Boolean)">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/>.
            When <paramref name="shortLived"/> is true, the <see cref="F:System.IO.FileAttributes.Temporary"/> is set on the file.
            </summary>
            <param name="shortLived">True to set the <see cref="F:System.IO.FileAttributes.Temporary"/> on the file.</param>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.String)">
            <summary>
            Initializes the TemporaryFile with an extension - the file will have a name looking like : xxxx.tmp.extension        
            </summary>
            <param name="extension">The extension of the file (example : '.png' and 'png' would both work) </param>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/> with an extension.
            When <paramref name="shortLived"/> is true, the <see cref="F:System.IO.FileAttributes.Temporary"/> is set on the file.
            The file will have a name looking like : xxxx.tmp.extension
            </summary>
            <param name="shortLived">True to set the <see cref="F:System.IO.FileAttributes.Temporary"/> on the file.</param>
            <param name="extension">The extension of the file (example : '.png' and 'png' would both work).</param>
        </member>
        <member name="M:CK.Core.TemporaryFile.Finalize">
            <summary>
            Finalizer attempts to delete the file.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.Detach">
            <summary>
            Detachs the temporary file: it will no more be automatically destroyed.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.Dispose">
            <summary>
            Attempts to delete the temporary file.
            </summary>
        </member>
        <member name="P:CK.Core.TemporaryFile.Path">
            <summary>
            Gets the complete file path of the temporary file.
            The file is not opened but exists, initiall
            </summary>
        </member>
        <member name="T:CK.Core.IWritableCollector`1">
            <summary>
            Contravariant interface for a collector: one can only add elements to a collector and know how muwh elements
            there are (Note that if you do not need the <see cref="P:CK.Core.IWritableCollector`1.Count"/>, you should use a simple Fun&lt;T,bool&gt;).
            </summary>
            <typeparam name="T">Base type for the elements of the collector.</typeparam>
        </member>
        <member name="M:CK.Core.IWritableCollector`1.Add(`0)">
            <summary>
            Adds an element to the collection. The exact behavior of this operation
            depends on the concrete implementation (duplicates, filters, etc.).
            </summary>
            <param name="e">Element to add.</param>
            <returns>True if the element has been added, false otherwise.</returns>
        </member>
        <member name="P:CK.Core.IWritableCollector`1.Count">
            <summary>
            Gets the count of elements in the collection.
            </summary>
        </member>
        <member name="T:CK.Core.InvalidFileException">
            <summary>
            <see cref="T:CK.Core.CKException"/> raised when something in a file goes wrong.
            </summary>
        </member>
        <member name="T:CK.Core.CKException">
            <summary>
            Basic <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String,System.Object[])">
            <summary>
            Constructor
            </summary>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Constructor
            </summary>
            <param name="innerException"></param>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Protected constructor, that will intialize the <see cref="T:CK.Core.CKException"/> with
            a <see cref="T:System.Runtime.Serialization.SerializationInfo"/> and a <see cref="T:System.Runtime.Serialization.StreamingContext"/>.
            </summary>
            <param name="info">Given to initialize the <see cref="T:CK.Core.CKException"/>.</param>
            <param name="context">Given to initialize the <see cref="T:CK.Core.CKException"/>.</param>
        </member>
        <member name="M:CK.Core.InvalidFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the object data.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="filePath"></param>
            <param name="message"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.String,System.String,System.Object[])">
            <summary>
            Constructor
            </summary>
            <param name="filePath"></param>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="filePath"></param>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.String,System.Exception,System.String,System.Object[])">
            <summary>
            Constructor
            </summary>
            <param name="filePath"></param>
            <param name="innerException"></param>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="P:CK.Core.InvalidFileException.FilePath">
            <summary>
            Gets the path of the current file.
            </summary>
        </member>
        <member name="T:CK.Core.ISimpleErrorMessage">
            <summary>
            Abstraction available to any object that exposes an <see cref="P:CK.Core.ISimpleErrorMessage.ErrorMessage"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ISimpleErrorMessage.IsWarning">
            <summary>
            Gets whether this error message should be considered only as a warning.
            </summary>
        </member>
        <member name="P:CK.Core.ISimpleErrorMessage.ErrorMessage">
            <summary>
            Gets an error message. May be null if no error is carried by the object.
            </summary>
        </member>
        <member name="T:CK.Core.IWritableCollection`1">
            <summary>
            Contravariant interface for a collection that allows to <see cref="M:CK.Core.IWritableCollection`1.Clear"/> and <see cref="M:CK.Core.IWritableCollection`1.Remove(`0)"/>
            element.
            </summary>
            <typeparam name="T">Base type for the elements of the collection.</typeparam>
        </member>
        <member name="M:CK.Core.IWritableCollection`1.Clear">
            <summary>
            Clears the collection.
            </summary>
        </member>
        <member name="M:CK.Core.IWritableCollection`1.Remove(`0)">
            <summary>
            Removes the element if it exists.
            </summary>
            <param name="e">Element to remove.</param>
            <returns>True if the element has been removed, false otherwise.</returns>
        </member>
        <member name="T:CK.Core.LogLevelFilter">
            <summary>
            Defines filters for <see cref="T:CK.Core.LogLevel"/>.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Trace">
            <summary>
            Everythnig is logged (<see cref="F:CK.Core.LogLevel.Trace"/>).
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Info">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Info"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Warn">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Warn"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Error">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Error"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Fatal">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Fatal"/> is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Off">
            <summary>
            Do not log anything.
            </summary>
        </member>
        <member name="T:CK.Core.IDefaultActivityLoggerSink">
            <summary>
            Simple activity logger implementation for <see cref="T:CK.Core.DefaultActivityLogger"/>.
            Inherits from this interface to implement your own logger (ie: XmlLogger).
            Each method described below provides an easy way to react to <see cref="T:CK.Core.IActivityLogger"/> calls.
            </summary>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnEnterLevel(CK.Core.LogLevel,System.String)">
            <summary>
            Called for the first text of a <see cref="T:CK.Core.LogLevel"/>.
            </summary>
            <param name="level">The new current log level.</param>
            <param name="text">Text to start.</param>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnContinueOnSameLevel(CK.Core.LogLevel,System.String)">
            <summary>
            Called for text with the same <see cref="T:CK.Core.LogLevel"/> as the previous ones.
            </summary>
            <param name="level">The current log level.</param>
            <param name="text">Text to append.</param>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnLeaveLevel(CK.Core.LogLevel)">
            <summary>
            Called when current log level changes.
            </summary>
            <param name="level">The previous log level.</param>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnGroupOpen(CK.Core.DefaultActivityLogger.Group)">
            <summary>
            Called whenever a group is opened.
            </summary>
            <param name="g">The newly opened group.</param>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnGroupClose(CK.Core.DefaultActivityLogger.Group,System.String)">
            <summary>
            Called whenever a group is closed.
            </summary>
            <param name="g">The closing group.</param>
            <param name="conclusion">Conclusion text.</param>
        </member>
        <member name="T:CK.Core.IFluentInterface">
            <summary>
            Helper interface used to hide the base <see cref="T:System.Object"/> members from the fluent API to make 
            for much cleaner Visual Studio intellisense experience. (Excellent idea borrowed from EntLib.)
            Use it on an interface: it must be the first interface (if more than one interface are supported) 
            to hide those useless methods. 
            </summary>
        </member>
        <member name="M:CK.Core.IFluentInterface.GetType">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.GetHashCode">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.ToString">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.Equals(System.Object)">
            <summary/>
        </member>
        <member name="T:CK.Core.XmlExtension">
            <summary>
            Extension methods for <see cref="T:System.Xml.XmlReader"/> and <see cref="T:System.Xml.Linq.XElement"/>
            classes.
            </summary>
        </member>
        <member name="M:CK.Core.XmlExtension.ReadEndElement(System.Xml.XmlReader,System.String)">
            <summary>
            Little helper that only increases source code readability: it calls <see cref="M:System.Xml.XmlReader.ReadEndElement"/>
            that checks the name of the closing element. This "helper" forces the developper to explicitely
            write this name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the closing element.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeBoolean(System.Xml.XmlReader,System.String,System.Boolean)">
            <summary>
            Gets a boolean attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeDateTime(System.Xml.XmlReader,System.String,System.DateTime)">
            <summary>
            Gets a <see cref="T:System.DateTime"/> attribute by name. It uses <see cref="F:System.Xml.XmlDateTimeSerializationMode.RoundtripKind"/>.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeVersion(System.Xml.XmlReader,System.String,System.Version)">
            <summary>
            Gets a <see cref="T:System.Version"/> attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeInt(System.Xml.XmlReader,System.String,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Int32"/> attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeEnum``1(System.Xml.XmlReader,System.String,``0)">
            <summary>
            Gets an enum value.
            </summary>
            <typeparam name="T">Type of the enum. There is no way (in c#) to constraint the type to Enum - nor to Delegate, this is why 
            the constraint restricts only the type to be a value type.</typeparam>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist or can not be parsed.</param>
            <returns>The parsed value or the default value.</returns>
        </member>
        <member name="M:CK.Core.XmlExtension.AttributeRequired(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            Gets the attribute by its name or throws an <see cref="T:System.Xml.XmlException"/> if it does not exist.
            </summary>
            <param name="r">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttribute(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.String)">
            <summary>
            Gets a string attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeBoolean(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Boolean)">
            <summary>
            Gets a boolean attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeDateTime(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.DateTime)">
            <summary>
            Gets a <see cref="T:System.DateTime"/> attribute by name. It uses <see cref="F:System.Xml.XmlDateTimeSerializationMode.RoundtripKind"/>.
            </summary>
            <param name="r">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeInt(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Int32"/> attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeEnum``1(System.Xml.Linq.XElement,System.Xml.Linq.XName,``0)">
            <summary>
            Gets an enum value.
            </summary>
            <typeparam name="T">Type of the enum. There is no way (in c#) to constraint the type to Enum - nor to Delegate, this is why 
            the constraint restricts only the type to be a value type.</typeparam>
            <param name="r">This <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist or can not be parsed.</param>
            <returns>The parsed value or the default value.</returns>
        </member>
        <member name="T:CK.Core.IObservableReadOnlyList`1">
            <summary>
            Definition of an <see cref="T:CK.Core.IObservableReadOnlyCollection`1"/> that is <see cref="T:CK.Core.IReadOnlyList`1"/> (the index of the elements make sense).
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="T:CK.Core.IObservableReadOnlyCollection`1">
            <summary>
            Definition of a <see cref="T:CK.Core.IReadOnlyCollection`1"/> that is observable through <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> and <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>.
            It has no properties nor methods by itself: it is only here to federate its 3 base interfaces.
            </summary>
            <typeparam name="T">The type of elements in the collection.</typeparam>
        </member>
        <member name="T:CK.Core.Wrapper`1">
            <summary>
            Simple wrapper: <see cref="P:CK.Core.Wrapper`1.Inner"/> property is the wrapped object.
            </summary>
            <typeparam name="T">Type of wrapped object.</typeparam>
        </member>
        <member name="M:CK.Core.Wrapper`1.#ctor(`0)">
            <summary>
            Initializes a wrapper around an object.
            </summary>
            <param name="inner">Wrapped object.</param>
        </member>
        <member name="M:CK.Core.Wrapper`1.CreateEnumerator``1(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,`0})">
            <summary>
            Creates a <see cref="T:System.Collections.IEnumerator"/> on a <see cref="T:System.Collections.IEnumerable"/> of another type.
            </summary>
            <typeparam name="TInner">Actual entity.</typeparam>
            <param name="e">Source enumerable.</param>
            <param name="converter">Converter from <typeparamref name="TInner"/> to <typeparamref name="T"/>.</param>
            <returns>An enumerator for the more abstract type.</returns>
        </member>
        <member name="P:CK.Core.Wrapper`1.Inner">
            <summary>
            Gets the wrapped object.
            </summary>
        </member>
        <member name="T:CK.Core.EnumerableConverter`2">
            <summary>
            Wraps a <see cref="T:System.Collections.IEnumerable"/> of a <typeparamref name="TOuter"/> type around a <see cref="T:System.Collections.IEnumerable"/>
            of <typeparamref name="TOuter"/> thanks to a conversion function.
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of enumerated objects.</typeparam>
        </member>
        <member name="M:CK.Core.EnumerableConverter`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Converter{`1,`0})">
            <summary>
            Initializes a new adapter.
            </summary>
            <param name="c">Enumerable to wrap.</param>
            <param name="converter">Conversion function to apply.</param>
        </member>
        <member name="M:CK.Core.EnumerableConverter`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through this enumerable.
            </summary>
            <returns>A IEnumerator that can be used to iterate through this enumerable.</returns>
        </member>
        <member name="P:CK.Core.EnumerableConverter`2.Converter">
            <summary>
            Gets the converter associated to this <see cref="T:CK.Core.EnumerableConverter`2"/>.
            </summary>
        </member>
        <member name="T:CK.Core.EnumerableConverter`2.EnumeratorAdapter">
            <summary>
            Internal implementation of the enumerator.
            </summary>
        </member>
        <member name="T:CK.Core.CollectionExtension">
            <summary>
            Provides extension methods for collection &amp; list interfaces.
            </summary>
        </member>
        <member name="M:CK.Core.CollectionExtension.AddRange``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds multiple items to a collection.
            </summary>
            <typeparam name="T">Collection items' type.</typeparam>
            <param name="c">This collection.</param>
            <param name="items">Multiple items to add. Can not be null.</param>
        </member>
        <member name="M:CK.Core.CollectionExtension.AddRangeArray``1(System.Collections.Generic.ICollection{``0},``0[])">
            <summary>
            Adds multiple items to a collection.
            </summary>
            <typeparam name="T">Collection items' type.</typeparam>
            <param name="c">This collection.</param>
            <param name="items">Items to add.</param>
        </member>
        <member name="T:CK.Core.WeakReference`1">
            <summary>
            A generic weak reference, which references an object while still allowing  
            that object to be reclaimed by garbage collection.   
            </summary>   
            <typeparam name="T">The type of the object that is referenced.</typeparam>
            <remarks>
            An implicit cast exists from <typeparamref name="T"/> to <see cref="T:CK.Core.WeakReference`1"/> 
            BUT NOT the opposite, and it is asolutely normal!
            </remarks>
        </member>
        <member name="M:CK.Core.WeakReference`1.#ctor(`0)">
            <summary>       
            Initializes a new instance of a weak reference to 
            the specified object.       
            </summary>       
            <param name="target">The object to reference.</param>       
        </member>
        <member name="M:CK.Core.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>       
            Initializes a new instance of the WeakReference{T} class, referencing
            the specified object and using the specified resurrection tracking.
            </summary>       
            <param name="target">An object to track.</param>
            <param name="trackResurrection">Indicates when to stop tracking the object. If true, the object is tracked
            after finalization; if false, the object is only tracked until finalization.</param>
        </member>
        <member name="M:CK.Core.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Required serialization constructor.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/>.</param>
        </member>
        <member name="M:CK.Core.WeakReference`1.op_Implicit(`0)~CK.Core.WeakReference{`0}">
            <summary>
            Casts an object of the type T to a weak reference of T.
            </summary>
        </member>
        <member name="P:CK.Core.WeakReference`1.Target">
            <summary>
            Gets or sets the object (the target) referenced by this weak reference.
            </summary>
        </member>
        <member name="T:CK.Core.IVersionedUniqueId">
            <summary>
            Extends <see cref="T:CK.Core.IUniqueId"/> to associate a <see cref="P:Version"/> number.
            </summary>
        </member>
        <member name="P:CK.Core.IVersionedUniqueId.Version">
            <summary>
            Gets the version number associated to this object.
            Never null: defaults to <see cref="F:CK.Core.Util.EmptyVersion"/>.
            </summary>
        </member>
        <member name="T:CK.Core.FileUtil">
            <summary>
            Helper functions related to file system.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.InexistingFile">
            <summary>
            Combination of <see cref="T:System.IO.FileAttributes"/> that can not exist: it can be used to 
            tag inexisting files among other existing (i.e. valid) file attributes.
            </summary>
        </member>
        <member name="M:CK.Core.FileUtil.GetFiles(System.String,System.String)">
            <summary>
            Returns files in a directory according to multiple file masks (separated by ';'). 
            </summary>
            <param name="path">Path of the directory to read.</param>
            <param name="multiFileMask">File masks, for example: <i>*.gif;*.jpg;*.png</i>.</param>
            <returns>List of files (without duplicates).</returns>
        </member>
        <member name="M:CK.Core.FileUtil.NormalizePathSeparator(System.String,System.Boolean)">
            <summary>
            Canonicalizes the path: all '/' and '\' are mapped to <see cref="F:System.IO.Path.DirectorySeparatorChar"/> 
            (and <see cref="F:System.IO.Path.AltDirectorySeparatorChar"/> will also be transformed).
            </summary>
            <param name="path">The path to standardize (can be not be null). It is trimmed and if the path is empty, the empty string is returned.</param>
            <param name="ensureTrailingBackslash">
            Ensures that the normalized path will end with a <see cref="F:System.IO.Path.DirectorySeparatorChar"/>.
            It should be true for path to directories because we consider that a directory path SHOULD end with 
            the slash as often as possible.
            When <paramref name="path"/> is empty, this is not applied to preserve the fact that the string is empty.
            </param>
            <returns>A standardized path, whatever the actual <c>Path.DirectorySeparatorChar</c> is
            on the current platform.</returns>
        </member>
        <member name="F:CK.Core.FileUtil.DirectorySeparatorString">
            <summary>
            Gets the <see cref="F:System.IO.Path.DirectorySeparatorChar"/> as a string.
            </summary>
        </member>
        <member name="M:CK.Core.FileUtil.IndexOfInvalidPathChars(System.String)">
            <summary>
            Finds the first character index of any characters that are invalid in a path.
            This method (and <see cref="M:CK.Core.FileUtil.IndexOfInvalidFileNameChars(System.String)"/>) avoid the allocation of 
            the array each time <see cref="M:System.IO.Path.GetInvalidPathChars"/> is called.
            </summary>
            <param name="path">Path to check. Can not be null.</param>
            <returns>A negative value if not found.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.IndexOfInvalidFileNameChars(System.String)">
            <summary>
            Finds the first character index of any characters that are invalid in a file name.
            This method (and <see cref="M:CK.Core.FileUtil.IndexOfInvalidPathChars(System.String)"/>) avoid the allocation of 
            the array each time <see cref="M:System.IO.Path.GetInvalidFileNameChars"/> is called.
            </summary>
            <param name="path">Path to check. Can not be null.</param>
            <returns>A negative value if not found.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.IsVolumeCaseSensitive(System.String)">
            <summary>
            Detects whether the given path is on a case sensitive volume or not.
            </summary>
            <param name="path">Path to a file.</param>
            <returns>True if this path must be treated as case sensitive.</returns>
        </member>
        <member name="M:CK.Core.FileUtil.CopyDirectory(System.IO.DirectoryInfo,System.IO.DirectoryInfo,System.Boolean,System.Boolean,System.Predicate{System.IO.FileInfo},System.Predicate{System.IO.DirectoryInfo})">
            <summary>
            Recursively copy a directory.
            </summary>
            <param name="src">The source directory.</param>
            <param name="target">The target directory.</param>
            <param name="withHiddenFiles">False to skip hidden files.</param>
            <param name="withHiddenFolders">False to skip hidden folders.</param>
            <param name="fileFilter">Optional predicate for directories.</param>
            <param name="dirFilter">Optional predicate for files.</param>
        </member>
        <member name="M:CK.Core.FileUtil.WaitForWriteAcccess(System.IO.FileInfo,System.Int32)">
            <summary>
            Waits for a file to be writable. Do not open the file.
            Waits approximately the number of seconds given before leaving and returning false.
            </summary>
            <param name="file">The file to write to.</param>
            <param name="nbMaxSecond">Maximum number of seconds to wait before returning false.</param>
            <returns>True if the file has been correctly opened in write mode.</returns>
        </member>
        <member name="T:CK.Core.FileUtil.VolumeFlags">
            <summary>
            Supporting flags that may be set on a file system (descriptions are from Win32 api).
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.None">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.CaseSensitive">
            <summary>
            The file system supports case-sensitive file names.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.PreservesCase">
            <summary>
            The file system preserves the case of file names when it places a name on disk.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.SupportsUnicodeOnVolume">
            <summary>
            The file system supports Unicode in file names as they appear on disk.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.PersistentAcls">
            <summary>
            The file system preserves and enforces ACLs. For example, NTFS preserves and enforces ACLs, and FAT does not.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.Compressed">
            <summary>
            The specified volume is a compressed volume; for example, a DoubleSpace volume.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.ReadOnly">
            <summary>
            The specified volume is read-only.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.SupportsEncryption">
            <summary>
            The file system supports the Encrypted File System (EFS).
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.SupportsFileCompression">
            <summary>
            The file system supports file-based compression.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.SupportsNamedStreams">
            <summary>
            The file system supports named streams.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.SupportsObjectIds">
            <summary>
            The file system supports object identifiers.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.SupportsQuotas">
            <summary>
            The file system supports disk quotas.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.SupportsReparsePoints">
            <summary>
            The file system supports reparse points.
            </summary>
        </member>
        <member name="F:CK.Core.FileUtil.VolumeFlags.SupportsSparseFiles">
            <summary>
            The file system supports sparse files.
            </summary>
        </member>
        <member name="T:CK.Core.ComponentModelExtension">
            <summary>
            Provides extension methods for system/component model interfaces.
            </summary>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.GetService``1(System.IServiceProvider,System.Boolean)">
            <summary>
            Strongly typed version of <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.
            </summary>
            <param name="source">This service provider.</param>
            <param name="throwOnNull">True to throw an exception if the service can not be provided (otherwise null is returned).</param>
            <returns>A service object of the required type or null if not found and <paramref name="throwOnNull"/> is false.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.GetService``1(System.IServiceProvider)">
            <summary>
            Strongly typed version of <see cref="M:System.IServiceProvider.GetService(System.Type)"/> that returns null if service is not found.
            (Same behavior as <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.)
            </summary>
            <param name="source">This service provider.</param>
            <returns>A service object of the required type or null if not found.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,``0)">
            <summary>
            Type safe version to register a service implementation (type of the service is the type of the implementation).
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,``0,System.Action{``0})">
            <summary>
            Type safe version to register a service implementation (type of the service is the type of the implementation), 
            and an optional callback that will be called when the service will be removed.
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,System.Func{``0})">
            <summary>
            Type safe version to register a service associated to a callback.
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,System.Func{``0},System.Action{``0})">
            <summary>
            Type safe version to register a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.ActivityLoggerExtension">
            <summary>
            Provides extension methods for <see cref="T:CK.Core.IActivityLogger"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.OpenGroup(CK.Core.IActivityLogger,CK.Core.LogLevel,System.String)">
            <summary>
            Opens a log level. <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)">CloseGroup</see> must be called in order to
            close the group, or the returned object must be disposed.
            </summary>
            <param name="l">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="level">The log level of the group.</param>
            <param name="text">The text associated to the opening of the log.</param>
            <returns>A disposable object that can be used to close the group.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.OpenGroup(CK.Core.IActivityLogger,CK.Core.LogLevel,System.Func{System.String},System.String,System.Object[])">
            <summary>
            Opens a log level. <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)">CloseGroup</see> must be called in order to
            close the group, or the returned object must be disposed.
            </summary>
            <param name="l">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="level">Log level. Since we are opening a group, the current <see cref="P:CK.Core.IActivityLogger.Filter">Filter</see> is ignored.</param>
            <param name="getConclusionText">Optional function that will be called on group closing.</param>
            <param name="format">A composite format for the group title.</param>
            <param name="arguments">Arguments to format.</param>
            <returns>A disposable object that can be used to close the group.</returns>
            <remarks>
            A group opening is not be filtered since any subordinated logs may occur.
            It is left to the implementation to handle (or not) filtering when <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)">CloseGroup</see> is called.
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.OpenGroup(CK.Core.IActivityLogger,CK.Core.LogLevel,System.String,System.Object[])">
            <summary>
            Opens a log level. <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)">CloseGroup</see> must be called in order to
            close the group, or the returned object must be disposed.
            </summary>
            <param name="l">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="level">Log level. Since we are opening a group, the current <see cref="P:CK.Core.IActivityLogger.Filter">Filter</see> is ignored.</param>
            <param name="format">Format of the string.</param>
            <param name="arguments">Arguments to format.</param>
            <returns>A disposable object that can be used to close the group.</returns>
            <remarks>
            A group opening is not be filtered since any subordinated logs may occur.
            It is left to the implementation to handle (or not) filtering when <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)">CloseGroup</see> is called.
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as a trace.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a trace.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a trace.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a trace.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a trace.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as an info.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an info.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an info.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an info.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an info.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as a warning.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a warning.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a warning.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a warning.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a warning.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as an error.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an error.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an error.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an error.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an error.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as a fatal error.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a fatal error.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a fatal error.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a fatal error.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a fatal error.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.ActionSequenceExtension">
            <summary>
            Holds extensions methods of <see cref="T:CK.Core.IActionSequence"/> interface.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater(CK.Core.IActionSequence,System.Action)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append(System.Action)">Appends</see> the action to this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="action">The action to execute. Can be null: in such case nothing is done.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater``1(CK.Core.IActionSequence,System.Action{``0},``0)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append``1(System.Action{``0},``0)">Appends</see> the action to this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="p">Parameter of the action.</param>
            <param name="action">The action to execute. Can be null: in such case nothing is done.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater``2(CK.Core.IActionSequence,System.Action{``0,``1},``0,``1)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append``2(System.Action{``0,``1},``0,``1)">Appends</see> the action to this <see cref="T:CK.Core.IActionSequence"/> if possible, 
            or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="action">The action to execute. Can be null: in such case nothing is done.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater``3(CK.Core.IActionSequence,System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append``3(System.Action{``0,``1,``2},``0,``1,``2)">Appends</see> the action to 
            this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="action">The action to execute. Can be null: in such case nothing is done.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
            <param name="p3">Third action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater(CK.Core.IActionSequence,System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append(System.EventHandler,System.Object,System.EventArgs)">Appends</see> an event raising to this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="e">The <see cref="T:System.EventHandler"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater``1(CK.Core.IActionSequence,System.EventHandler{``0},System.Object,``0)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append``1(System.EventHandler{``0},System.Object,``0)">Appends</see> an event raising to this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <typeparam name="T">Must be a class that inherits from <see cref="T:System.EventArgs"/>.</typeparam>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="e">The <see cref="T:System.EventHandler`1"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="T:CK.Core.ActionSequence">
            <summary>
            Implementation of <see cref="T:CK.Core.IActionSequence"/>. 
            Actions are executed when one of the <see cref="M:CK.Core.ActionSequence.Run"/> methods is called and in the order they have been added.
            An action that is executing can <see cref="M:Append"/> a new action that will be executed later
            but during the same current <see cref="M:CK.Core.ActionSequence.Run"/> call.
            </summary>
            <remarks>
            This is a low level implementation: no cycle nor call reentrancy detection are made. It is 
            up to the developper to correctly append the actions to the sequence.
            </remarks>
        </member>
        <member name="T:CK.Core.IActionSequence">
            <summary>
            Provides a way to stack <see cref="T:System.Action"/>s and to defer their execution. 
            This interface only defines append behavior.
            </summary>
        </member>
        <member name="M:CK.Core.IActionSequence.Append(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Appends an event raising.
            </summary>
            <param name="e">The <see cref="T:System.EventHandler"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Appends an event raising.
            </summary>
            <typeparam name="T">Must be a class that inherits from <see cref="T:System.EventArgs"/>.</typeparam>
            <param name="e">The <see cref="T:System.EventHandler`1"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append(System.Action)">
            <summary>
            Appends an action (without parameters).
            </summary>
            <param name="action">No parameter <see cref="T:System.Action"/> delegate.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append``1(System.Action{``0},``0)">
            <summary>
            Appends an action (with one parameter).
            </summary>
            <param name="action">One parameter <see cref="T:System.Action"/> delegate.</param>
            <param name="parameter">Action parameter.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Appends an action (with two parameters).
            </summary>
            <param name="action">Two parameters <see cref="T:System.Action"/> delegate.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Appends an action (with three parameters).
            </summary>
            <param name="action">Three parameters <see cref="T:System.Action"/> delegate.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
            <param name="p3">Third action parameter.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Clear">
            <summary>
            Removes all recorded actions.
            </summary>
        </member>
        <member name="P:CK.Core.IActionSequence.ReadOnly">
            <summary>
            Gets a boolean that states whether this sequence is read-only. 
            When a sequence is read-only, any attempt to append an action is an error (an exception must be thrown).
            Defaults to false.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequence.Append(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Appends an event raising.
            </summary>
            <param name="e">The <see cref="T:System.EventHandler"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Appends an event raising.
            </summary>
            <typeparam name="T">Must be a class that inherits from <see cref="T:System.EventArgs"/>.</typeparam>
            <param name="e">The <see cref="T:System.EventHandler`1"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append(System.Action)">
            <summary>
            Appends an action (without parameters).
            </summary>
            <param name="action">No parameter <see cref="T:System.Action"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append``1(System.Action{``0},``0)">
            <summary>
            Appends an action (with one parameter).
            </summary>
            <param name="action">One parameter <see cref="T:System.Action"/> delegate.</param>
            <param name="parameter">Action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Appends an action (with two parameters).
            </summary>
            <param name="action">Two parameters <see cref="T:System.Action"/> delegate.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Appends an action (with three parameters).
            </summary>
            <param name="action">Three parameters <see cref="T:System.Action"/> delegate.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
            <param name="p3">Third action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Clear">
            <summary>
            Removes all recorded actions.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequence.Run">
            <summary>
            Invokes the sequence of actions and keep them in this sequence.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequence.RunOnce">
            <summary>
            Invokes the sequence of actions and forget them as soon as they are executed.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequence.RunOnceSafe">
            <summary>
            Invokes the sequence of actions and forget them as soon as they are executed.
            Traps any exception and continues the execution.
            </summary>
            <returns>A non empty list of exceptions if (at least) one error occured, null in no error occured.</returns>
        </member>
        <member name="P:CK.Core.ActionSequence.ReadOnly">
            <summary>
            Gets or sets a boolean that states whether this sequence is read-only. 
            When a sequence is read-only, any attempt to append an action is an error (an
            exception will be thrown).
            Defaults to false.
            </summary>
        </member>
        <member name="T:CK.Core.Adapter">
            <summary>
            </summary>
        </member>
        <member name="M:CK.Core.Adapter.ToPredicate``1(System.Action{``0},System.Boolean)">
            <summary>
            Wraps an action in a predicate that returns always the provided result.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="a">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <param name="result">result that will be returned.</param>
            <returns>A predicate that performs the action and returns true.</returns>
        </member>
        <member name="M:CK.Core.Adapter.AlwaysTrue``1(System.Action{``0})">
            <summary>
            Wraps an action in a predicate that returns always true.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="a">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <returns>A predicate that performs the action and returns true.</returns>
        </member>
        <member name="M:CK.Core.Adapter.AlwaysFalse``1(System.Action{``0})">
            <summary>
            Wraps an action in a predicate that returns always false.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="a">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <returns>A predicate that performs the action and returns false.</returns>
        </member>
        <member name="T:CK.Core.IMergeable">
            <summary>
            Simple interface to support merging of information from external objects.
            </summary>
        </member>
        <member name="M:CK.Core.IMergeable.Merge(System.Object,System.IServiceProvider)">
            <summary>
            Attempts to merge this object with the given one.
            This method should not raise any exception. Instead, false should be returned. 
            If an exception is raised, callers should handle the exception and behaves as if the method returned false.
            </summary>
            <param name="source">Source object to merge into this one.</param>
            <param name="services">Optional services (can be null) that can be injected into the merge process.</param>
            <returns>True if the merge succeeded, false if the merge failed or is not possible.</returns>
        </member>
        <member name="T:CK.Core.ReadOnlyCollectionTypeConverter`2">
            <summary>
            Wraps a <see cref="T:CK.Core.IReadOnlyCollection`1"/> of a <typeparamref name="TOuter"/> type around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            of <typeparamref name="TInner"/> (the <see cref="P:CK.Core.ReadOnlyCollectionTypeConverter`2.Inner"/> collection).
            The converter from inner objects to outer objects is required (to expose the content). 
            An optional converter (outer to inner) enables O(1) <see cref="M:CK.Core.ReadOnlyCollectionTypeConverter`2.Contains(System.Object)"/> method if the inner collection
            supports O(1) <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/> method (this is the case of dictionary Keys collection).
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of the objects contained in the <see cref="P:CK.Core.ReadOnlyCollectionTypeConverter`2.Inner"/> collection.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionTypeConverter`2.#ctor(System.Collections.Generic.ICollection{`1},System.Converter{`1,`0},System.Converter{`0,`1})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionTypeConverter`2"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            thanks to a <see cref="T:System.Converter`2"/> and an optional <see cref="T:System.Converter`2"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
            <param name="innerToOuter">The converter function from <typeparamref name="TInner"/> to <typeparamref name="TOuter"/>.</param>
            <param name="outerToInner">
            Optional converter from <typeparamref name="TOuter"/> to <typeparamref name="TInner"/>. 
            When null, the <see cref="M:CK.Core.ReadOnlyCollectionTypeConverter`2.Contains(System.Object)"/> method is O(n) instead of O(1) if the inner collection is an index.
            </param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionTypeConverter`2.#ctor(System.Collections.Generic.ICollection{`1},System.Converter{`1,`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionTypeConverter`2"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            thanks to a <see cref="T:System.Converter`2"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
            <param name="innerToOuter">The converter function from <typeparamref name="TInner"/> to <typeparamref name="TOuter"/>.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionTypeConverter`2.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionTypeConverter`2.Inner">
            <summary>
            Wrapped <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionTypeConverter`2.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.SortedArrayKeyList`2">
            <summary>
            Sorted list of items where the sort order relies on an external key, not the item itself.
            </summary>
        </member>
        <member name="T:CK.Core.SortedArrayList`1">
            <summary>
            Simple sorted array list implementation that supports covariance through <see cref="T:CK.Core.IReadOnlyList`1"/> and contravariance 
            with <see cref="T:CK.Core.IWritableCollection`1"/>.
            </summary>
            <remarks>
            This class implements <see cref="T:System.Collections.Generic.IList`1"/> both for performance (unfortunately Linq relies -too much- on it) and for interoperability reasons: this
            interface should NOT be used. Accessors of the <see cref="T:System.Collections.Generic.IList`1"/> that defeats the invariant of this class (the fact that elements are sorted, such 
            as <see cref="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)"/>) are explicitely implemented to hide them as much as possible.
            </remarks>
        </member>
        <member name="F:CK.Core.SortedArrayList`1.Comparator">
            <summary>
            Specialized implementation can use this comparison function if needed.
            </summary>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.SortedArrayList`1"/> that rejects duplicates 
            and uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> comparer.
            </summary>
            <remarks>
            A default constructor is a parameterless constructor, it is not the same as a constructor with default parameter values.
            This is why it is explicitely defined.
            </remarks>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.#ctor(System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SortedArrayList`1"/> that rejects or allows duplicates 
            and uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> comparer.
            </summary>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.#ctor(System.Collections.Generic.IComparer{`0},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SortedArrayList`1"/> that rejects or allows duplicates 
            and uses the given comparer.
            </summary>
            <param name="comparer">Comparer to use.</param>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.#ctor(System.Comparison{`0},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SortedArrayList`1"/> that rejects or allows duplicates 
            and uses the given comparison function.
            </summary>
            <param name="comparison">Comparison function to use.</param>
            <param name="allowDuplicates">True to allow duplicate elements.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Explicitely implemented since our <see cref="M:CK.Core.SortedArrayList`1.Add(`0)"/> method
            returns a boolean.
            </summary>
            <param name="item">Item to add.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.IndexOf(`0)">
            <summary>
            Locates an element in this list. 
            </summary>
            <param name="value">The element.</param>
            <returns>The result of the <see cref="M:CK.Core.Util.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Comparison{``0})"/> in the internal array.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.Contains(`0)">
            <summary>
            Determines whether this <see cref="T:CK.Core.SortedArrayList`1"/> contains a specific value.
            </summary>
            <param name="value">The value.</param>
            <returns>True if the object is found; otherwise, false.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.IndexOf(System.Object)">
            <summary>
            Covariant compatible overload of <see cref="M:CK.Core.SortedArrayList`1.IndexOf(`0)"/>.
            If the item is not <typeparamref name="T"/> compatible, the 
            value <see cref="F:System.Int32.MinValue"/> is returned. See <see cref="M:CK.Core.IReadOnlyList`1.IndexOf(System.Object)"/>.
            </summary>
            <param name="item">The item to locate.</param>
            <returns>
            Positive index when found, negative one when not found and <see cref="F:System.Int32.MinValue"/> 
            if the item can structurally NOT appear in this list.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.Contains(System.Object)">
            <summary>
            Covariant compatible overload of <see cref="M:CK.Core.SortedArrayList`1.Contains(`0)"/>.
            </summary>
            <param name="item">The item to find.</param>
            <returns>True if the object is found; otherwise, false.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the content of the internal array into the given array.
            </summary>
            <param name="array">Destination array.</param>
            <param name="arrayIndex">Index at which copying must start.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.Remove(`0)">
            <summary>
            Removes a value and returns true if found; otherwise returns false.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>True if the value has been found and removed, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <summary>
            Explicit implementation to hide it as much as possible. 
            It calls the protected virtual <see cref="M:CK.Core.SortedArrayList`1.DoInsert(System.Int32,`0)"/> method
            that does the job of actually inserting the item at the given index... 
            even if this breaks the sort.
            </summary>
            <param name="index">Future index of the item.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.Add(`0)">
            <summary>
            Adds the item at its right position depending on the comparison function and returns true.
            May return false if, for any reason, the item has not been added. At this level (but this 
            may be overriden), if <see cref="P:CK.Core.SortedArrayList`1.AllowDuplicates"/> is false and the item already exists,
            false is returned and the item is not added.
            </summary>
            <param name="value">Item to add.</param>
            <returns>True if the item has actually been added; otherwise false.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the given position.
            </summary>
            <param name="index">Index to remove.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.Clear">
            <summary>
            Clears the list.
            </summary>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.CheckPosition(System.Int32)">
            <summary>
            Checks that the item at the given index is between a lesser and a greater item and if not, 
            moves the item at its correct index.
            If the new index conflicts because <see cref="P:CK.Core.SortedArrayList`1.AllowDuplicates"/> is false (the default), a 
            negative value is returned, otherwise the new positive index is returned.
            </summary>
            <param name="index">Index of the element to check.</param>
            <returns>
            The new positive index if the position has been successfuly updated, or a negative value
            if a duplicate exists (and <see cref="P:CK.Core.SortedArrayList`1.AllowDuplicates"/> is false).
            </returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.DoSet(System.Int32,`0)">
            <summary>
            Sets a value at a given position.
            </summary>
            <param name="index">The position to set.</param>
            <param name="newValue">The new item to inject.</param>
            <returns>The previous item at the position.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.DoInsert(System.Int32,`0)">
            <summary>
            Inserts a new item.
            </summary>
            <param name="index">Index to insert.</param>
            <param name="value">Item to insert.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.DoClear">
            <summary>
            Clears the list.
            </summary>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.DoRemoveAt(System.Int32)">
            <summary>
            Removes the item at a given position.
            </summary>
            <param name="index">Index to remove.</param>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.DoMove(System.Int32,System.Int32)">
            <summary>
            Moves an item from a position to another one.
            </summary>
            <param name="from">Old index of the item.</param>
            <param name="newIndex">New index.</param>
            <returns></returns>
        </member>
        <member name="M:CK.Core.SortedArrayList`1.GetEnumerator">
            <summary>
            Gets an enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CK.Core.SortedArrayList`1.AllowDuplicates">
            <summary>
            Gets whether this list allows duplicated items.
            </summary>
        </member>
        <member name="P:CK.Core.SortedArrayList`1.Count">
            <summary>
            Gets the number of elements in this sorted list.
            </summary>
        </member>
        <member name="P:CK.Core.SortedArrayList`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Explicit implementation that always returns false.
            </summary>
        </member>
        <member name="P:CK.Core.SortedArrayList`1.Capacity">
            <summary>
            Gets or sets the current capacity of the internal array.
            When setting it, if the new capacity is less than the current <see cref="P:CK.Core.SortedArrayList`1.Count"/>, 
            an <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
        </member>
        <member name="P:CK.Core.SortedArrayList`1.Item(System.Int32)">
            <summary>
            Gets the object at the given index.
            </summary>
            <param name="index">Zero based position of the item in this list.</param>
            <returns>The item.</returns>
        </member>
        <member name="P:CK.Core.SortedArrayList`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <summary>
            Explicit implementation to hide it as much as possible. 
            The setter calls the protected virtual <see cref="M:CK.Core.SortedArrayList`1.DoSet(System.Int32,`0)"/> method
            that does the job of actually setting the item at the given index... 
            even if this breaks the sort.
            </summary>
            <param name="index">Index of the item.</param>
            <returns>The item.</returns>
        </member>
        <member name="P:CK.Core.SortedArrayList`1.Store">
            <summary>
            Gives access to the internal array to specialized classes.
            </summary>
        </member>
        <member name="T:CK.Core.IReadOnlyMultiKeyedCollection`2">
            <summary>
            Represents a generic read only keyed collections of covariant items with
            a contravariant key that can support duplicate items.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
            <typeparam name="TKey">The type of the key associated to the elements.</typeparam>
        </member>
        <member name="M:CK.Core.IReadOnlyMultiKeyedCollection`2.KeyCount(`1)">
            <summary>
            Gets the number of items in this keyed collection that are associated to the
            given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>Number of items with the <paramref name="key"/>.</returns>
        </member>
        <member name="M:CK.Core.IReadOnlyMultiKeyedCollection`2.GetAllByKey(`1)">
            <summary>
            Gets an independant collection of the items that 
            are associated to the given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>An independant collection of <typeparamref name="T"/>.</returns>
        </member>
        <member name="P:CK.Core.IReadOnlyMultiKeyedCollection`2.AllowDuplicates">
            <summary>
            Gets whether this collection supports duplicates.
            </summary>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.#ctor(System.Func{`0,`1},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SortedArrayKeyList`2"/>.
            </summary>
            <param name="keySelector">Function that associates a key to an item.</param>
            <param name="allowDuplicates">True to allow duplicates.</param>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.#ctor(System.Func{`0,`1},System.Comparison{`1},System.Boolean)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SortedArrayKeyList`2"/> where a <see cref="T:System.Comparison`1"/> function
            is used to compare keys.
            </summary>
            <param name="keySelector">Function that associates a key to an item.</param>
            <param name="keyComparison">Function used to compare keys.</param>
            <param name="allowDuplicates">True to allow duplicates.</param>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.IndexOf(`1)">
            <summary>
            Gets the zero based position of on of the items that is associated to this key.
            </summary>
            <param name="key">The key to find.</param>
            <returns>The index or a negative value like <see cref="M:CK.Core.Util.BinarySearch``2(``0[],System.Int32,System.Int32,``1,System.Func{``0,``1,System.Int32})"/>.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.Contains(`1)">
            <summary>
            True if this list contains at least one item with the given key.
            </summary>
            <param name="key">The key to find.</param>
            <returns>True if an item is foud, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.GetByKey(`1,System.Boolean@)">
            <summary>
            Gets the first item with a given key or the default value if no such item exist.
            </summary>
            <param name="key">The key.</param>
            <param name="exists">True if the key has been found, otherwise false.</param>
            <returns>The item or default(T) if not found.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.KeyCount(`1)">
            <summary>
            Gets the number of items with a given key. It can be greater than 1 only if <see cref="P:CK.Core.SortedArrayList`1.AllowDuplicates">AllowDuplicates</see> is true.
            </summary>
            <param name="key">The key to find.</param>
            <returns>The number of item with the <paramref name="key"/>.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.GetAllByKey(`1)">
            <summary>
            Gets an independant collection of the items that 
            are associated to the given key value.
            </summary>
            <param name="key">The key to find.</param>
            <returns>An independant collection of <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.IndexOf(`0)">
            <summary>
            Gets the index of the element thanks to a linear search into the 
            internal array.
            If the key did not change, it is more efficient to find an element with <see cref="M:CK.Core.SortedArrayKeyList`2.IndexOf(`1)"/> that 
            uses a dichotomic search.
            </summary>
            <param name="value">The element to locate.</param>
            <returns>The index in array that, if found; otherwise, 1.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.IndexOf(System.Object)">
            <summary>
            Covariant IndexOf method: if <paramref name="item"/> is of type <typeparamref name="T"/>
            the <see cref="M:CK.Core.SortedArrayKeyList`2.IndexOf(`0)"/> is used but if <paramref name="item"/> is of type <typeparamref name="TKey"/>,
            the <see cref="M:CK.Core.SortedArrayKeyList`2.IndexOf(`1)"/> is used.
            </summary>
            <param name="item">Can be a <typeparamref name="T"/> or a <typeparamref name="TKey"/>.</param>
            <returns>The index of the item in the collection.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.Contains(System.Object)">
            <summary>
            Covariant version of the contains predicate. If <paramref name="item"/> is of type <typeparamref name="T"/>
            the <see cref="M:CK.Core.SortedArrayList`1.Contains(`0)"/> is used but if <paramref name="item"/> is of type <typeparamref name="TKey"/>,
            the <see cref="M:CK.Core.SortedArrayKeyList`2.Contains(`1)"/> is used.
            </summary>
            <param name="item">Can be a <typeparamref name="T"/> or a <typeparamref name="TKey"/>.</param>
            <returns>True if a corresponding element in this list can be found.</returns>
        </member>
        <member name="M:CK.Core.SortedArrayKeyList`2.Remove(`1)">
            <summary>
            Removes one item given a key: only one item is removed when <see cref="P:CK.Core.SortedArrayList`1.AllowDuplicates"/> is 
            true and more than one item are associated to this key.
            </summary>
            <param name="key">The key to remove.</param>
            <returns>True if an item has been removed, false otherwise.</returns>
        </member>
        <member name="T:CK.Core.R">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CK.Core.R.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CK.Core.R.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:CK.Core.R.ActionSequenceReadOnly">
            <summary>
              Looks up a localized string similar to ActionSequence is read only: no action can be appended..
            </summary>
        </member>
        <member name="P:CK.Core.R.ArgumentCountNegative">
            <summary>
              Looks up a localized string similar to Argument count can not be negative..
            </summary>
        </member>
        <member name="P:CK.Core.R.DirectServicesCanNotBeDisabled">
            <summary>
              Looks up a localized string similar to Service {0} is direcly supported by the container. It can not be disabled..
            </summary>
        </member>
        <member name="P:CK.Core.R.ExceptionWhileResolvingType">
            <summary>
              Looks up a localized string similar to An exception occured while resolving type: {0}..
            </summary>
        </member>
        <member name="P:CK.Core.R.ExpectedXmlAttribute">
            <summary>
              Looks up a localized string similar to Expected attribute &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:CK.Core.R.ExpectedXmlEndElement">
            <summary>
              Looks up a localized string similar to Expected EndElement token named {0}..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceAlreadyDirectlySupported">
            <summary>
              Looks up a localized string similar to Service {0} is directly supported by the container..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceAlreadyRegistered">
            <summary>
              Looks up a localized string similar to Service {0} is already registered by the container..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceImplCallbackTypeMismatch">
            <summary>
              Looks up a localized string similar to Service {0} is not implemented by object {1} returned by the callback..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceImplTypeMismatch">
            <summary>
              Looks up a localized string similar to Service {0} is not implemented by object {1}..
            </summary>
        </member>
        <member name="P:CK.Core.R.UnregisteredServiceInServiceProvider">
            <summary>
              Looks up a localized string similar to Unable to find service &apos;{0}&apos;..
            </summary>
        </member>
        <member name="T:CK.Core.EnumEmpty`1">
            <summary>
            Defines a unique empty enumerator.
            Use <see cref="F:CK.Core.ReadOnlyListEmpty`1.Empty"/> singleton for an empty <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="F:CK.Core.EnumEmpty`1.Empty">
            <summary>
            Gets the default <see cref="T:CK.Core.EnumEmpty`1"/>.
            This field is static readonly and is thread safe by design.
            </summary>
        </member>
        <member name="M:CK.Core.EnumEmpty`1.Dispose">
            <summary>
            Dispose the enumerator.
            </summary>
        </member>
        <member name="M:CK.Core.EnumEmpty`1.MoveNext">
            <summary>
            Move to the next element of the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CK.Core.EnumEmpty`1.Reset">
            <summary>
            Reset the enumerator.
            </summary>
        </member>
        <member name="P:CK.Core.EnumEmpty`1.Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
        <member name="T:CK.Core.DictionaryExtension">
            <summary>
            Provides extension methods for <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetValueWithDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value associated with the specified key if it exists otherwise returns the <paramref name="defaultValue"/>.
            </summary>
            <param name="that">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">Default value to use if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the <paramref name="defaultValue"/>. 
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetValueWithDefaultFunc``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Gets the value associated with the specified key if it exists otherwise calls the <paramref name="defaultValue"/> function.
            </summary>
            <param name="that">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">A delegate that will be called if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the result 
            of the <paramref name="defaultValue"/> delegate.
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Gets the value associated with the specified key if it exists otherwise calls the <paramref name="createValue"/> function
            and adds the newly obtained value into the dictionary.
            </summary>
            <param name="that">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="createValue">A delegate that will be called if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the result 
            of the <paramref name="createValue"/> delegate (this result has been added to the dictionary).
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Adds the content of a dictionary to this <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="that">This generic IDictionary.</param>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> from which content will be copied.</param>
        </member>
        <member name="T:CK.Core.ISimpleTypeFinder">
            <summary>
            This simple interface allows to resolve types from names.
            </summary>
            <remarks>
            Types mapping is an option that should be used with care.    
            </remarks>
        </member>
        <member name="M:CK.Core.ISimpleTypeFinder.MapType(System.String)">
            <summary>
            Gets an (optionnal) mapping from any name of a type to the actual
            assembly qualified name that must be used for it.
            This function MUST be idempotent (ie. MapType( MapType(x) ) == MapType(x) whatever x is).
            Its default implementation is simply to return its parameter unchanged (no mapping).
            </summary>
            <param name="externalName">The assembly qualified name of a type.</param>
            <returns>The assembly qualified name (that <see cref="M:CK.Core.ISimpleTypeFinder.ResolveType(System.String,System.Boolean)"/> can use) of the type to use.</returns>
        </member>
        <member name="M:CK.Core.ISimpleTypeFinder.ResolveType(System.String,System.Boolean)">
            <summary>
            First calls <see cref="M:CK.Core.ISimpleTypeFinder.MapType(System.String)"/> and then resolves the <see cref="T:System.Type"/> from the mapped string.
            If <paramref name="throwOnError"/> is true, a <see cref="T:System.TypeLoadException"/> will be fired if the resolution fails.
            </summary>
            <param name="externalName">Assembly qualified name of the type</param>
            <param name="throwOnError">
            True to ALWAYS throw a <see cref="T:System.TypeLoadException"/> if the type is not found.
            False prevents any exception to be thrown and simply returns null.
            </param>
            <returns>The type or null if not found and <paramref name="throwOnError"/> is false.</returns>
            <exception cref="T:System.TypeLoadException">
            When <paramref name="throwOnError"/> is true, always throws this kind of exception.
            The original error (not a <see cref="T:System.TypeLoadException"/>) is available in the <see cref="P:System.Exception.InnerException"/>.
            </exception>
        </member>
        <member name="T:CK.Core.ReadOnlyExtension">
            <summary>
            Provides extension methods for <see cref="T:CK.Core.IReadOnlyCollection`1"/>, <see cref="T:CK.Core.IReadOnlyList`1"/> and <see cref="T:CK.Core.IReadOnlyUniqueKeyedCollection`2"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.GetByKey``2(CK.Core.IReadOnlyUniqueKeyedCollection{``0,``1},``1)">
            <summary>
            Gets the item with the associated key, forgetting the exists out parameter in <see cref="M:CK.Core.IReadOnlyUniqueKeyedCollection`2.GetByKey(`1,System.Boolean@)"/>.
            </summary>
            <typeparam name="T">Type of the elements in the collection.</typeparam>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="coll">Keyed collection of elements.</param>
            <param name="key">The item key.</param>
            <returns>The item that matches the key, default(T) if the key can not be found.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToArray``1(CK.Core.IReadOnlyCollection{``0})">
            <summary>
            Creates an array from a read only collection.
            This is a much more efficient version than the IEnumerable ToArray extension method
            since this implementation allocates one and only one array. 
            </summary>
            <typeparam name="T">Type of the array and lists elements.</typeparam>
            <param name="list">Read only collection of elements.</param>
            <returns>A new array that contains the same element as the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains the conversion of elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a sub sequence of a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Int32,System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a sub sequence of a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains the converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> starting at a given index.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate, starting at a given index.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of out.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> that is a copy of the <see cref="T:System.Collections.Generic.ICollection`1"/> content.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input collection following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.ICollection{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input collection following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input sequence following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a sub seqence of a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Int32,System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a sub seqence of a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate, starting at a given index.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <returns>A read only collection that contains the elements from the input collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.ICollection{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only collection.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the conversion of elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a read only list from.</param>
            <returns>A read only collection that contains the elements from the input sequence following the enumeration order.</returns>
        </member>
        <member name="T:CK.Core.ReadOnlyListOnIList`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.IList`1"/> object to the <see cref="T:CK.Core.IReadOnlyList`1"/> interface.
            The other <see cref="T:CK.Core.ReadOnlyListOnIList`2"/> generic can expose (wrap) a list of TInner 
            as a readonly list of T where TInner is a T.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyListOnIList`1"/> around a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="list">List to wrap.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in list.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>The index of item if found in the list; otherwise a negative value (see <see cref="M:CK.Core.IReadOnlyList`1.IndexOf(System.Object)"/>).</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.Contains(System.Object)">
            <summary>
            Whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`1.Inner">
            <summary>
            Gets or sets the wrapped list.
            </summary>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="i">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="i"/> is not a valid index in the list.</exception>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyListOnIList`2">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.IList`1"/> object to the <see cref="T:CK.Core.IReadOnlyList`1"/> interface
            where TInner is a T.
            </summary>
            <typeparam name="T">Type of the exposed element.</typeparam>
            <typeparam name="TInner">Type of the list element.</typeparam>
            <remarks>
            There is no way to define a beast like <c>ReadOnlyListOnIList&lt;T, TInner&gt; where TInner : T</c> that would 
            extend <see cref="T:System.Collections.Generic.IList`1"/> because of the GetEnumerator support.
            <para>
            The adapter object would have to implement both GetEnumerator() methods (for TInner and T), and even if the constraint states that
            TInner is T and the IEnumerator is covariant, this is rejected with the following error: cannot implement 
            both 'IEnumerable&lt;T&gt;' and 'System.Collections.Generic.IEnumerable&lt;TInner&gt;' because they may unify 
            for some type parameter substitutions.
            </para>
            </remarks>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`2.#ctor(System.Collections.Generic.IList{`1})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyListOnIList`1"/> around a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="list">List to wrap.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`2.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in list.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>The index of item if found in the list; otherwise a negative value (see <see cref="M:CK.Core.IReadOnlyList`1.IndexOf(System.Object)"/>).</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`2.Contains(System.Object)">
            <summary>
            Whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`2.Inner">
            <summary>
            Gets or sets the wrapped list.
            </summary>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`2.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="i">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="i"/> is not a valid index in the list.</exception>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`2.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleNamedVersionedUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.INamedVersionedUniqueId"/> interface.
            </summary>
        </member>
        <member name="T:CK.Core.INamedVersionedUniqueId">
            <summary>
            Extends <see cref="T:CK.Core.IVersionedUniqueId"/> to associate a <see cref="P:PublicName"/> descriptor.
            </summary>
        </member>
        <member name="P:CK.Core.INamedVersionedUniqueId.PublicName">
            <summary>
            Gets the public name of this object. 
            It mmust never be null (defaults to <see cref="F:System.String.Empty"/>) and can be any string 
            in any culture (english US should be used as much a possible).
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.INamedVersionedUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/>, <see cref="F:CK.Core.Util.EmptyVersion"/> and <see cref="F:System.String.Empty"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.INamedVersionedUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a temporary marker.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.EmptyArray">
            <summary>
            Empty array of <see cref="T:CK.Core.IUniqueId"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.String,System.Version,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version object. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name for the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name of the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.Guid,System.Version,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/>.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name of the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.Version">
            <summary>
            Gets the version of this object.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.PublicName">
            <summary>
            Gets the public name of this object.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleErrorMessage">
            <summary>
            Basic implementation of <see cref="T:CK.Core.ISimpleErrorMessage"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleErrorMessage.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleErrorMessage"/> with 
            a null <see cref="P:CK.Core.SimpleErrorMessage.ErrorMessage"/>.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleErrorMessage.IsWarning">
            <summary>
            Gets or sets whether this error message 
            should be considered only as a warning.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleErrorMessage.ErrorMessage">
            <summary>
            Gets or sets an error message. Can be null.
            </summary>
        </member>
        <member name="T:CK.Core.ObservableSortedArrayList`1">
            <summary>
            </summary>
        </member>
        <member name="E:CK.Core.ObservableSortedArrayList`1.CollectionChanged">
            <summary>
            Standard <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> event.
            </summary>
        </member>
        <member name="E:CK.Core.ObservableSortedArrayList`1.PropertyChanged">
            <summary>
            Standard <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> event.
            </summary>
        </member>
        <member name="T:CK.Core.ChangeStatus">
            <summary>
            Defines a common change status: it captures the main kind of changes
            that an object or container can support.
            This status does not pretend to describe all and every possible changes, it is a
            trade-off between explicit, simple and well defined terms and the horrifying complexity reality.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.None">
            <summary>
            No operation occured.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.Update">
            <summary>
            Denotes the update of an object.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.Add">
            <summary>
            Denotes a new object (typically the appearing of an item in a collection).
            It should have been named 'Appear' but 'Add' is a much more common term to refer
            to object apparition in classical collection scenario.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.Delete">
            <summary>
            Denotes the suppression of an object (typically the removing of an item from a collection).
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.ContainerClear">
            <summary>
            Denotes the suppression of the content of a container object (typically when destroying a collection): no more content exist.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.ContainerUpdate">
            <summary>
            Denotes a global change in the content of container object (typically the replacement of items in a collection with items from another one).
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.ContainerDestroy">
            <summary>
            Denotes a global change in the content of container object (typically when clearing a collection): no more values exist.
            </summary>
        </member>
        <member name="T:CK.Core.Util">
            <summary>
            Utility class.
            </summary>
        </member>
        <member name="M:CK.Core.Util.Log2(System.UInt32)">
            <summary>
            Compute the Log2 (logarithm base 2) of a given number.
            </summary>
            <param name="v">Integer to compute</param>
            <returns>Log2 of the given integer</returns>
        </member>
        <member name="M:CK.Core.Util.Log2ForPower2(System.UInt32)">
            <summary>
            Compute the Log2ForPower2 (logarithm base 2 power 2) of a given number.
            </summary>
            <param name="v">Integer to compute. It MUST be a power of 2.</param>
            <returns>Result</returns>
        </member>
        <member name="M:CK.Core.Util.BitCount(System.Byte)">
            <summary>
            Counts the number of bits in the given byte.
            </summary>
            <param name="v">The value for which number of bits must be computed.</param>
            <returns>The number of bits.</returns>
        </member>
        <member name="F:CK.Core.Util.EmptyStringArray">
            <summary>
            Gets a static empty <see cref="T:System.String"/> array.
            </summary>
        </member>
        <member name="F:CK.Core.Util.EmptyVersion">
            <summary>
            The empty version is defined as the Major.Minor.Build.Revision set to "0.0.0.0".
            </summary>
        </member>
        <member name="M:CK.Core.Util.ActionDispose(System.IDisposable)">
            <summary>
            Centralized <see cref="M:System.IDisposable.Dispose"/> action call: it adapts an <see cref="T:System.IDisposable"/> interface to an <see cref="T:System.Action"/>.
            Can be safely called if <paramref name="obj"/> is null. 
            See <see cref="M:CK.Core.Util.DisposeAction(System.Action)"/> to wrap an action in a <see cref="T:System.IDisposable"/> interface.
            </summary>
            <param name="obj">The disposable object to dispose (can be null).</param>
        </member>
        <member name="M:CK.Core.Util.DisposeAction(System.Action)">
            <summary>
            Wraps an action in a <see cref="T:System.IDisposable"/> interface
            Can be safely called if <paramref name="a"/> is null (the dispose call will do nothing).
            See <see cref="M:CK.Core.Util.ActionDispose(System.IDisposable)"/> to adapt an <see cref="T:System.IDisposable"/> interface to an <see cref="T:System.Action"/>.
            </summary>
            <param name="a">The action to call when <see cref="M:System.IDisposable.Dispose"/> is called.</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``1(``0)">
            <summary>
            Centralized void action call for any type. 
            This method is the safest method never written. 
            It does absolutely nothing.
            </summary>
            <param name="obj">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``2(``0,``1)">
            <summary>
            Centralized void action call for any pair of types. 
            This method is the safest method never written. 
            It does absolutely nothing.
            </summary>
            <param name="o1">Any object.</param>
            <param name="o2">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``3(``0,``1,``2)">
            <summary>
            Centralized void action call for any 3 types. 
            This method is the safest method never written. 
            It does absolutely nothing.
            </summary>
            <param name="o1">Any object.</param>
            <param name="o2">Any object.</param>
            <param name="o3">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.FuncIdentity``1(``0)">
            <summary>
            Centralized identity function for any type.
            </summary>
            <typeparam name="T">Type of the function parameter and return value.</typeparam>
            <param name="value">Any value returned unchanged.</param>
            <returns>The <paramref name="value"/> provided is returned as-is.</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Comparison{``0})">
            <summary>
            Binary search immplementation that relies on a <see cref="T:System.Comparison`1"/>.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
            <param name="array">An array of elements.</param>
            <param name="startIndex">The starting index in the array.</param>
            <param name="length">The number of elements to consider in the array.</param>
            <param name="value">The value to locate.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="M:CK.Core.Util.BinarySearch``2(``0[],System.Int32,System.Int32,``1,System.Func{``0,``1,System.Int32})">
            <summary>
            Binary search immplementation that relies on an extended comparer: a function that knows how to 
            compare the elements of the array to a key of another type.
            </summary>
            <typeparam name="T">Type of the elements.</typeparam>
            <typeparam name="TKey">Type of the key.</typeparam>
            <param name="array">An array of elements.</param>
            <param name="startIndex">The starting index in the array.</param>
            <param name="length">The number of elements to consider in the array.</param>
            <param name="key">The value of the key.</param>
            <param name="comparison">The comparison function.</param>
            <returns>Same as <see cref="M:System.Array.BinarySearch(System.Array,System.Object)"/>: negative index if not found which is the bitwise complement of (the index of the next element plus 1).</returns>
        </member>
        <member name="F:CK.Core.Util.SqlServerEpoch">
            <summary>
            Gets 1900, january the 1st. This is the 'zero' of Sql Server datetime and smalldatetime
            types.
            </summary>
        </member>
        <member name="F:CK.Core.Util.UnixEpoch">
            <summary>
            Gets 1970, january the 1st. This is the 'zero' of numerous date/time system
            like Unix file system or javascript.
            </summary>
        </member>
        <member name="T:CK.Core.Util.Hash">
            <summary>
            Provides methods to combine hash values.
            Based on Daniel J. Bernstein algorithm (http://cr.yp.to/cdb/cdb.txt).
            </summary>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Int32)">
            <summary>
            Combines an existing hash value with a new one.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="value">Value to combine.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Object)">
            <summary>
            Combines an existing hash value with an object's hash (object can be null).
            </summary>
            <param name="hash">Current hash.</param>
            <param name="o">Object whose hash must be combined (can be null).</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Collections.IEnumerable)">
            <summary>
            Combines an existing hash value with multiples object's hash.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="c">Multiple objects. Can be null.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="M:CK.Core.Util.Hash.Combine(System.Int64,System.Object[])">
            <summary>
            Combines an existing hash value with multiples object's written directly as parameters.
            </summary>
            <param name="hash">Current hash.</param>
            <param name="objects">Multiple objects.</param>
            <returns>A combined hash.</returns>
        </member>
        <member name="P:CK.Core.Util.Hash.StartValue">
            <summary>
            Gets a very classical start value.
            It seems that this value has nothing special (mathematically speaking) except that it 
            has been used and reused by many people since DJB choose it.
            </summary>
        </member>
        <member name="T:CK.Core.FIFOBuffer`1">
            <summary>
            Simple implementation of a FIFO stack based on a circular buffer.
            Note that when <typeparamref name="T"/> is a reference type, null can be pushed and pop.
            </summary>
            <typeparam name="T">Type of the items.</typeparam>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.#ctor(System.Int32)">
            <summary>
            Initializes a new <see cref="T:CK.Core.FIFOBuffer`1"/> with an initial capacity.
            </summary>
            <param name="capacity">Initial capacity (can be 0).</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Contains(System.Object)">
            <summary>
            Tests whether the buffer actually contains the given object.
            </summary>
            <param name="item">Object to test.</param>
            <returns>True if the object exists.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the given object.
            </summary>
            <param name="item">Object to find.</param>
            <returns>The index of the object or -1 if not found.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.IndexOf(`0)">
            <summary>
            Gets the index of the given object.
            </summary>
            <param name="item">Object to find.</param>
            <returns>
            The index of the object or the bitwise complement of <see cref="P:CK.Core.FIFOBuffer`1.Count"/> if not 
            found (that is a negative value, see <see cref="M:CK.Core.IReadOnlyList`1.IndexOf(System.Object)"/>).
            </returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Clear">
            <summary>
            Clears the internal buffer.
            </summary>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Push(`0)">
            <summary>
            Adds an item.
            </summary>
            <param name="item">Item to push.</param>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Pop">
            <summary>
            Gets and removes the first item (the one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>ed first).
            </summary>
            <returns>The first (oldest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.Peek">
            <summary>
            Gets the first item (the one that has been <see cref="M:CK.Core.FIFOBuffer`1.Push(`0)"/>ed first).
            </summary>
            <returns>The first (oldest) item.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[])">
            <summary>
            Copies as much possible items into the given array. 
            If the target array is too small to contain <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies as much possible items into the given array. 
            If the target array is too small to contain <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <param name="arrayIndex">Index in <paramref name="array"/> where copy must start.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies as much possible items into the given array. 
            If <paramref name="count"/> is less than <see cref="P:CK.Core.FIFOBuffer`1.Count"/>, the newest ones
            are copied (the oldest, the ones that will <see cref="M:CK.Core.FIFOBuffer`1.Pop"/> first, are skipped).
            </summary>
            <param name="array">Array that will contain the items.</param>
            <param name="arrayIndex">Index in <paramref name="array"/> where copy must start.</param>
            <param name="count">Number of items to copy.</param>
            <returns>Number of items copied.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.GetEnumerator">
            <summary>
            Gets the enumerator.
            </summary>
            <returns>An enumerator (from oldest to newest item).</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.ToArray">
            <summary>
            Creates an array that contains <see cref="P:CK.Core.FIFOBuffer`1.Count"/> items.
            </summary>
            <returns>An array with the contained items.</returns>
        </member>
        <member name="M:CK.Core.FIFOBuffer`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Non-generic version of <see cref="M:CK.Core.FIFOBuffer`1.GetEnumerator"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Capacity">
            <summary>
            Gets or sets the capacity (internal buffer will be resized).
            </summary>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Count">
            <summary>
            Gets the actual count of element: it is necessary less than or equal to <see cref="P:CK.Core.FIFOBuffer`1.Capacity"/>.
            </summary>
        </member>
        <member name="P:CK.Core.FIFOBuffer`1.Item(System.Int32)">
            <summary>
            Gets the element by index. Index 0 is the one returned by <see cref="M:CK.Core.FIFOBuffer`1.Peek"/> (and the next one that will be returned by <see cref="M:CK.Core.FIFOBuffer`1.Pop"/>).
            </summary>
            <param name="index">Index must be positive and less than <see cref="P:CK.Core.FIFOBuffer`1.Count"/>.</param>
            <returns>The indexed element.</returns>
        </member>
        <member name="T:CK.Core.LogLevel">
            <summary>
            Five standard log levels in increasing order used by <see cref="T:CK.Core.IActivityLogger"/>.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Trace">
            <summary>
            A trace logging level (the most verbose level).
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Info">
            <summary>
            An info logging level.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Warn">
            <summary>
            A warn logging level.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Error">
            <summary>
            An error logging level: denotes an error for the current activity. 
            This error does not necessarily abort the activity.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Fatal">
            <summary>
            A fatal error logging level: denotes an error that breaks (aborts)
            the current activity. This kind of error may have important side effects
            on the system.
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyListMono`1">
            <summary>
            Implements a mono element <see cref="T:CK.Core.IReadOnlyList`1"/>.
            </summary>
            <typeparam name="T">The type of element in the read only list.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyListMono`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="val">Element contained by the <see cref="T:CK.Core.ReadOnlyListMono`1"/></param>
        </member>
        <member name="M:CK.Core.ReadOnlyListMono`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the given item.
            </summary>
            <param name="item">Item to find</param>
            <returns>Index of the item, 0 or <see cref="F:System.Int32.MinValue"/> if it is not found</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListMono`1.Contains(System.Object)">
            <summary>
            Gets if the given item is contained into the list.
            </summary>
            <param name="item">Item to find</param>
            <returns>True if the item is found, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListMono`1.GetEnumerator">
            <summary>
            Gets the underlying enumerator, <see cref="T:CK.Core.EnumMono`1"/> actually.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListMono`1.Item(System.Int32)">
            <summary>
            Gets the item at the given index.
            </summary>
            <param name="i">Index of the item to find.</param>
            <returns>Found item at the index. If the index is not 0 an <see cref="T:System.IndexOutOfRangeException"/> will be thrown.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListMono`1.Count">
            <summary>
            Gets the count of the list, 1 in all cases.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleTypeFinder">
            <summary>
            Very simple default implementation of the <see cref="T:CK.Core.ISimpleTypeFinder"/>: it can be used as a base class.
            A static <see cref="F:CK.Core.SimpleTypeFinder.Default"/> is available.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleTypeFinder.Default">
            <summary>
            Default implementation for <see cref="T:CK.Core.ISimpleTypeFinder"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.MapType(System.String)">
            <summary>
            Default implementation returns exactly its <paramref name="assemblyQualifiedName"/> parameter.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name of a type.</param>
            <returns>The assembly qualified name to use.</returns>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.ResolveType(System.String,System.Boolean)">
            <summary>
            Simple implementation that calls <see cref="M:CK.Core.SimpleTypeFinder.MapType(System.String)"/> and then <see cref="M:System.Type.GetType(System.String,System.Boolean)"/>.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name of a type.</param>
            <param name="throwOnError">
            True to ALWAYS throw a <see cref="T:System.TypeLoadException"/> if the type is not found.
            False prevents any exception to be thrown and simply returns null.
            </param>
            <returns>The type or null if not found and <paramref name="throwOnError"/> is false.</returns>
            <exception cref="T:System.TypeLoadException">
            When <paramref name="throwOnError"/> is true, always throws this kind of exception.
            The original error (not a <see cref="T:System.TypeLoadException"/>) is available in the <see cref="P:System.Exception.InnerException"/>.
            </exception>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.SplitNames(System.String,System.String@,System.String@)">
            <summary>
            Helper method to split the assembly qualified name into its assembly name and full type name.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name to split.</param>
            <param name="assemblyName">Assembly name on output or an empty string.</param>
            <param name="fullTypeName">Full type name on output or an empty string.</param>
            <returns>True if the split has been successfully done. False otherwise.</returns>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.SplitAssemblyFullName(System.String,System.String@,System.String@)">
            <summary>
            Helper method to split an assembly full name in two parts.
            </summary>
            <param name="assemblyFullName">The assembly full name.</param>
            <param name="assemblyName">Set to assembly name only.</param>
            <param name="versionCultureAndPublicKeyToken">Set to extra information.</param>
            <returns>True if the split worked.</returns>
        </member>
        <member name="T:CK.Core.MissingDisposeCallSentinel">
             <summary>
             Helper class that helps detecting missing calls to <see cref="M:System.IDisposable.Dispose"/>.
             </summary>
             <example>
             Sample code for a simple class (if unmanaged resources are involved or may be involved by the disposable object,
             the standard Dispose(bool disposing) pattern must be implemented.
             <code>
             class DisposableClassDebug : IDisposable
             {
             #if DEBUG
                 MissingDisposeCallSentinel _sentinel = new MissingDisposeCallSentinel();
                 ~DisposableClassDebug()
                 {
                     MissingDisposeCallSentinel.RegisterMissing( _sentinel );
                 }
             #endif
            
                 public void Dispose()
                 {
             #if DEBUG
                     _sentinel = null;
                     GC.SuppressFinalize( this );
             #endif
                 }
             }
             </code> 
             </example>
        </member>
        <member name="F:CK.Core.MissingDisposeCallSentinel.Time">
            <summary>
            Creation time of the <see cref="T:System.IDisposable"/> object.
            </summary>
        </member>
        <member name="F:CK.Core.MissingDisposeCallSentinel.ThreadId">
            <summary>
            Thread identifier that created the <see cref="T:System.IDisposable"/> object.
            </summary>
        </member>
        <member name="F:CK.Core.MissingDisposeCallSentinel.StackTrace">
            <summary>
            Stack trace of the <see cref="T:System.IDisposable"/> object creation.
            </summary>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.MissingDisposeCallSentinel"/>. 
            Should be called during a field initializer in the <see cref="T:System.IDisposable"/> object.
            </summary>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.ToString">
            <summary>
            Overriden to return <see cref="F:CK.Core.MissingDisposeCallSentinel.Time"/>, <see cref="F:CK.Core.MissingDisposeCallSentinel.ThreadId"/> and <see cref="F:CK.Core.MissingDisposeCallSentinel.StackTrace"/>.
            </summary>
            <returns>Creation time information.</returns>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.Clear">
            <summary>
            Clears all registered <see cref="T:CK.Core.MissingDisposeCallSentinel"/>
            This method is thread safe.
            </summary>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.DumpMissing">
            <summary>
            Gets a string with missing dispose information. Null if <see cref="P:CK.Core.MissingDisposeCallSentinel.HasMissingDisposeCall"/> is false.
            This method is thread safe.
            </summary>
            <returns>Number of missing dispose and related information to each of them.</returns>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.RegisterMissing(CK.Core.MissingDisposeCallSentinel)">
            <summary>
            Registers a sentinel. Should be called from the <see cref="T:System.IDisposable"/> object finalizer.
            This method is thread safe.
            </summary>
            <param name="s">A <see cref="T:CK.Core.MissingDisposeCallSentinel"/>. Can be null (to avoid the test in the caller).</param>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.DebugCheckMissing(System.Action{System.String})">
            <summary>
            DEBUG must be active (at the caller level). Typical use: <code>DebugCheckMissing( s =&gt; Debug.Fail( s ) );</code>.
            (<see cref="M:System.Diagnostics.Debug.Fail(System.String)"/> can not be used as a delegate because of its own <see cref="T:System.Diagnostics.ConditionalAttribute"/>.)
            Triggers <see cref="M:System.GC.Collect(System.Int32)"/> to detect missing dispose calls.
            </summary>
        </member>
        <member name="P:CK.Core.MissingDisposeCallSentinel.Missing">
            <summary>
            Gets all the <see cref="T:CK.Core.MissingDisposeCallSentinel"/> that been registered via <see cref="M:CK.Core.MissingDisposeCallSentinel.RegisterMissing(CK.Core.MissingDisposeCallSentinel)"/>.
            This method is thread safe.
            </summary>
        </member>
        <member name="P:CK.Core.MissingDisposeCallSentinel.HasMissingDisposeCall">
            <summary>
            True if any missing call to dispose have been detected.
            This method is thread safe.
            </summary>
        </member>
        <member name="T:CK.Core.DefaultActivityLogger">
            <summary>
            Basic implementation of <see cref="T:CK.Core.IActivityLogger"/>. 
            Handles the groups opening/closing stack and multiplexes calls to <see cref="T:CK.Core.IDefaultActivityLoggerSink"/>.
            For more control, the nested <see cref="T:CK.Core.DefaultActivityLogger.Group"/> class may also be overriden.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.DefaultActivityLogger"/>.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Register(CK.Core.IDefaultActivityLoggerSink)">
            <summary>
            Registers an <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> to the logger collection.
            Duplicate <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> are silently ignored.
            </summary>
            <param name="l">An activity logger implementation</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Unregister(CK.Core.IDefaultActivityLoggerSink)">
            <summary>
            Unregisters the given <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> from the collection of loggers.
            Silently ignored unregistered logger.
            </summary>
            <param name="l">An activity logger implementation</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.FirstLogger``1">
            <summary>
            Gets the first <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> that is comaptible with <typeparamref name="T"/> type.
            </summary>
            <typeparam name="T">Type of the logger that must be returned.</typeparam>
            <returns>The first compatible implementation, or null if no compatible logger exists.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.FirstLogger(System.Type)">
            <summary>
            Gets the first <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> that is comaptible with <paramref name="loggerType"/> type.
            </summary>
            <param name="loggerType">Type of the logger that must be returned.</param>
            <returns>The first compatible implementation, or null if no compatible logger exists.</returns>
        </member>
        <member name="F:CK.Core.DefaultActivityLogger.Empty">
            <summary>
            Empty <see cref="T:CK.Core.IActivityLogger"/>: nothing is done.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.UnfilteredLog(CK.Core.LogLevel,System.String)">
            <summary>
            Do log the text regardless of current <see cref="P:CK.Core.DefaultActivityLogger.Filter"/>.
            </summary>
            <param name="level">The log level.</param>
            <param name="text">The text to log.</param>
            <returns>This <see cref="T:CK.Core.IActivityLogger"/> to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.OpenGroup(CK.Core.LogLevel,System.Func{System.String},System.String)">
            <summary>
            Opens a <see cref="T:CK.Core.DefaultActivityLogger.Group"/> configured with the given parameters.
            </summary>
            <param name="level">The log level of the group.</param>
            <param name="getConclusionText">Optional function that will be called on group closing. </param>
            <param name="text">The text associated to the opening of the log.</param>
            <returns>The <see cref="T:CK.Core.DefaultActivityLogger.Group"/>.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.CloseGroup(System.String)">
            <summary>
            Closes the current <see cref="T:CK.Core.DefaultActivityLogger.Group"/>.
            </summary>
            <param name="conclusion">Text to conclude the group.</param>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.CreateGroup(CK.Core.LogLevel,System.String,System.Func{System.String})">
            <summary>
            Factory method for <see cref="T:CK.Core.DefaultActivityLogger.Group"/> (or any specialized class).
            This is may be overriden in advanced scenario where groups may support more 
            information than the default ones.
            </summary>
            <param name="level">The <see cref="P:CK.Core.DefaultActivityLogger.Group.GroupLevel"/> of the group.</param>
            <param name="text">The <see cref="P:CK.Core.DefaultActivityLogger.Group.GroupText"/>.</param>
            <param name="getConclusionText">An optional delegate to call on close to obtain a conclusion text.</param>
            <returns>A new group.</returns>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.RegisteredLoggers">
            <summary>
            Gets an enumeration of registered <see cref="T:CK.Core.IDefaultActivityLoggerSink"/>.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Filter">
            <summary>
            Gets or sets the current <see cref="T:CK.Core.LogLevelFilter"/>.
            </summary>
        </member>
        <member name="T:CK.Core.DefaultActivityLogger.Group">
            <summary>
            Groups are linked together from the current one to the very first one.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Group.#ctor(CK.Core.DefaultActivityLogger,CK.Core.LogLevel,System.String,System.Func{System.String})">
            <summary>
            Initializes a new <see cref="T:CK.Core.DefaultActivityLogger.Group"/> object.
            </summary>
            <param name="logger">The logger.</param>
            <param name="level">The <see cref="P:CK.Core.DefaultActivityLogger.Group.GroupLevel"/>.</param>
            <param name="text">The <see cref="P:CK.Core.DefaultActivityLogger.Group.GroupText"/>.</param>
            <param name="getConclusionText">The delegate to call on close to obtain a conclusion text.</param>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Group.ConsumeConclusionText">
            <summary>
            Calls <see cref="P:CK.Core.DefaultActivityLogger.Group.GetConclusionText"/> and sets it to null.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Group.Dispose">
            <summary>
            Ensures that any opened groups after this one are closed before closing this one.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Group.OnGroupClose(System.String)">
            <summary>
            Called whenever a group is closing.
            Must return the actual conclusion that will be used for the group: currently combines
            the <see cref="P:CK.Core.DefaultActivityLogger.Group.GetConclusionText"/> functions and the <paramref name="externalConclusion"/>
            in one string.
            </summary>
            <param name="externalConclusion">Conclusion parameter: comes from <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)"/>. Can be null.</param>
            <returns>The final conclusion to use.</returns>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.Logger">
            <summary>
            Gets the associated logger. Null whenever this group is closed.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.OpeningFilter">
            <summary>
            Gets the <see cref="T:CK.Core.LogLevelFilter"/> that was active when the 
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.Parent">
            <summary>
            Previous group. Null if this is the first opened group.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.Depth">
            <summary>
            Depth of this group (number of parent groups).
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.GroupLevel">
            <summary>
            Log level with which this group has been opened.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.GroupText">
            <summary>
            Text with which this group has been opened.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.GetConclusionText">
            <summary>
            Optional function that will be called on group closing. 
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyCollectionOnISet`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.HashSet`1"/> object to the <see cref="T:CK.Core.IReadOnlyCollection`1"/> interface.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnISet`1.#ctor(System.Collections.Generic.ISet{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionOnISet`1"/> around a <see cref="T:System.Collections.Generic.ISet`1"/>.
            </summary>
            <param name="c">Hash set to wrap.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnISet`1.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnISet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionOnISet`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.EnumerableExtension">
            <summary>
            Provides extension methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedStrict``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks whether the enumerable is in strict (no duplicates) ascending order (uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> Compare method).
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="source">This enumerable.</param>
            <returns>True if the enumerable is empty or is in strict ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedLarge``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks whether the enumerable is in large (duplicates allowed) ascending order (uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> Compare method).
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="source">This enumerable.</param>
            <returns>True if the enumerable is empty or is in large ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedStrict``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Checks whether the enumerable is in strict (no duplicates) ascending order based on a comparison function.
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="source">This enumerable.</param>
            <param name="comparison">The delegate used to compare elements.</param>
            <returns>True if the enumerable is empty or is in strict ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedLarge``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Checks whether the enumerable is in large (duplicates allowed) ascending order based on a comparison function.
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="source">This enumerable.</param>
            <param name="comparison">The delegate used to compare elements.</param>
            <returns>True if the enumerable is empty or is in large ascending order.</returns>
        </member>
        <member name="T:CK.Core.ISimpleServiceContainer">
            <summary>
            Defines a container for services.
            </summary>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})">
            <summary>
            Registers a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Object,System.Action{System.Object})">
            <summary>
            Registers a service with its implementation (and an optional callback that will be called when the service will be removed).
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)">
            <summary>
            Unregisters a service. Can be called even if the service does not exist.
            The service is first removed and then the OnRemove associated action is called if it exists:
            this enables OnRemove action to be bound to a method that safely calls back this Remove method.
            </summary>
            <param name="serviceType">Service type to unregister.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Clear">
            <summary>
            Unregisters all the services. Any "on remove" actions are executed.
            </summary>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.AddDisabled(System.Type)">
            <summary>
            Disables a service: null will always be returned by this <see cref="M:System.IServiceProvider.GetService(System.Type)"/>
            regardless of any fallbacks that may exist for this container.
            </summary>
            <remarks>
            This is not the same as calling <see cref="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})"/> with a null instance. A null instance for a service (a callback that always returns null)
            is nearly the same as calling <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>: any fallbacks (to a base <see cref="T:System.IServiceProvider"/> for example) can occur.
            This is stronger since this must prevent fallbacks.
            </remarks>
            <param name="serviceType">Service type to disable. It must not already exist in this container otherwise an exception is thrown.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.SimpleVersionedUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.INamedVersionedUniqueId"/> interface.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleVersionedUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.INamedVersionedUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/> and <see cref="F:CK.Core.Util.EmptyVersion"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleVersionedUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.INamedVersionedUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a temporary marker.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleVersionedUniqueId.EmptyArray">
            <summary>
            Empty array of <see cref="T:CK.Core.IUniqueId"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.String,System.Version)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version object. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.Guid,System.Version)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/>.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="P:CK.Core.SimpleVersionedUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleVersionedUniqueId.Version">
            <summary>
            Gets the version of this object.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleServiceContainer">
            <summary>
            Service container (that is a <see cref="T:System.IServiceProvider"/>) subordinated to an optional base IServiceProvider 
            that acts as a fallback if the service is not found at this level.
            Service creation may be deferred thanks to callback registration and an optional remove callback can be registered
            with each entry.
            </summary>
            <remarks>
            This container is registered as the service associated to <see cref="T:System.IServiceProvider"/> and <see cref="T:CK.Core.ISimpleServiceContainer"/>
            thanks to the overridable <see cref="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)"/>. This method may be overriden to return other built-in services: these services
            take precedence over the registered services.
            </remarks>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleServiceContainer"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.#ctor(System.IServiceProvider)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleServiceContainer"/> with a <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/>.
            </summary>
            <param name="baseProvider">Base <see cref="T:System.IServiceProvider"/> provider.</param>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})">
            <summary>
            Registers a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Object,System.Action{System.Object})">
            <summary>
            Registers a service with its implementation (and an optional callback that will be called when the service will be removed).
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.AddDisabled(System.Type)">
            <summary>
            Disables a service: null will always be returned by this <see cref="M:System.IServiceProvider.GetService(System.Type)"/>
            regardless of any fallbacks from <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/>. 
            Direct services returned by <see cref="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)"/> can not be disabled.
            </summary>
            <remarks>
            This is not the same as calling <see cref="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})"/> with a null instance. A null instance for a service (a callback that always returns null)
            is nearly the same as calling <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>: any fallbacks (to a base <see cref="T:System.IServiceProvider"/> for example) can occur.
            This is stronger since this must prevent fallbacks.
            </remarks>
            <param name="serviceType">Service type to disable. It must not already exist in this container otherwise an exception is thrown.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Remove(System.Type)">
            <summary>
            Unregisters a service. Can be called even if the service does not exist.
            The service is first removed and then the OnRemove associated action is called if it exists.
            </summary>
            <param name="serviceType">Service type to unregister.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Clear">
            <summary>
            Unregisters all the services. Any "on remove" actions are executed.
            </summary>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.GetService(System.Type)">
            <summary>
            Implements <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.
            </summary>
            <param name="serviceType">Type of the service to obtain.</param>
            <returns>Built-in service, registered service, service from <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/> or null.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)">
            <summary>
            Must return built-in services if any. These services take precedence over any registered services.
            This base implementation returns this object for <see cref="T:System.IServiceProvider"/> and <see cref="T:CK.Core.ISimpleServiceContainer"/>.
            </summary>
            <param name="serviceType">Type of the service to obtain.</param>
            <returns>A built-in service or null.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Dispose">
            <summary>
            Disposing calls <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> to unregister all services. Any "on remove" actions are executed.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.DoAdd(System.Type,CK.Core.SimpleServiceContainer.ServiceEntry)">
            <summary>
            Correct ArgumentException throw by a Dictionary when adding an existing key. 
            </summary>
        </member>
        <member name="P:CK.Core.SimpleServiceContainer.BaseProvider">
            <summary>
            Gets or sets the <see cref="T:System.IServiceProvider"/> that is queried whenever a service
            is not found in this container.
            </summary>
        </member>
        <member name="T:CK.Core.Impl.ReadOnlyCollectionDebuggerView`1">
            <summary>
            Debugger object for <see cref="T:CK.Core.IReadOnlyCollection`1"/>.
            </summary>
            <typeparam name="T">Type of elements in the collection.</typeparam>
        </member>
        <member name="M:CK.Core.Impl.ReadOnlyCollectionDebuggerView`1.#ctor(CK.Core.IReadOnlyCollection{`0})">
            <summary>
            Called by the debugger when needed.
            </summary>
            <param name="collection">The collection to debug.</param>
        </member>
        <member name="P:CK.Core.Impl.ReadOnlyCollectionDebuggerView`1.Items">
            <summary>
            Gets the items as a flattened array view.
            </summary>
        </member>
        <member name="T:CK.Core.ObservableSortedArrayKeyList`2">
            <summary>
            A <see cref="T:CK.Core.SortedArrayKeyList`2"/> that implements <see cref="E:CK.Core.ObservableSortedArrayKeyList`2.CollectionChanged"/> and <see cref="E:CK.Core.ObservableSortedArrayKeyList`2.PropertyChanged"/> events
            in order to be an observable collection.
            </summary>
        </member>
        <member name="E:CK.Core.ObservableSortedArrayKeyList`2.CollectionChanged">
            <summary>
            Standard <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> event.
            </summary>
        </member>
        <member name="E:CK.Core.ObservableSortedArrayKeyList`2.PropertyChanged">
            <summary>
            Standard <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> event.
            </summary>
        </member>
    </members>
</doc>
