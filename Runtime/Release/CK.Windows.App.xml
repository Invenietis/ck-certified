<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CK.Windows.App</name>
    </assembly>
    <members>
        <member name="T:CK.Windows.App.IRecoveryFunctions">
            <summary>
            Native mapping for <see cref="T:CK.Windows.App.AppRecoveryManager"/>.
            </summary>
        </member>
        <member name="T:CK.Windows.App.AppRecoveryManager">
            <summary>
            Static class that handles application recovery. 
            Gracefully handles the fact that <see cref="P:CK.Windows.App.AppRecoveryManager.IsOSRecoveryAvailable"/> is actually false.
            Relies on <see cref="T:CK.Windows.App.CrashLogManager"/> to log unhandled exceptions.
            </summary>
        </member>
        <member name="M:CK.Windows.App.AppRecoveryManager.Initialize(System.String)">
            <summary>
            Must be called once and only once.
            Registers the application for notification by windows of a failure if <see cref="P:CK.Windows.App.AppRecoveryManager.IsOSRecoveryAvailable"/> is true.
            Initializes the <see cref="T:CK.Windows.App.CrashLogManager"/> with the given directory.
            </summary>
            <returns>True if successfully registered for restart notification. False otherwise.</returns>   
            <remarks>
            <para>
            The <see cref="!:AppDomain.CurrentDomain.UnhandledException"/> event is listened and react to such unhandled exceptions
            int two different ways: If <see cref="P:CK.Windows.App.AppRecoveryManager.IsOSRecoveryAvailable"/> is true, the exception is memorized and will be dumped out
            to the crash log during application recovery. If it is false, this immediately triggers the <see cref="E:CK.Windows.App.AppRecoveryManager.ApplicationCrashed"/>
            event.
            </para>
            <para>
            Windows forms is configured to let unhandled execptions be thrown thanks to a call to <see cref="!:Application.SetUnhandledExceptionMode"/> with <see cref="!:UnhandledExceptionMode.ThrowException"/>.
            </para>
            <para>
            This method also initializes the <see cref="P:CK.Windows.App.AppRecoveryManager.CurrentCrashCount"/> from the <see cref="M:System.Environment.GetCommandLineArgs"/> (if any).
            </para>
            </remarks>
        </member>
        <member name="M:CK.Windows.App.AppRecoveryManager.HandleApplicationCrashByOS(System.IntPtr)">
            <summary>
            This is the callback function that is executed in the event of the application crashing.
            </summary>
            <param name="pvParameter">Unused unmanaged pointer.</param>
            <returns>Always returns 0.</returns>
        </member>
        <member name="M:CK.Windows.App.AppRecoveryManager.CheckForRecoveryCancel(System.Object)">
            <summary>
            Checks to see if the user has cancelled the recovery.
            </summary>
            <param name="o"></param>
        </member>
        <member name="P:CK.Windows.App.AppRecoveryManager.IsOSRecoveryAvailable">
            <summary>
            Gets whether the OS is able to recover the application.
            </summary>
        </member>
        <member name="E:CK.Windows.App.AppRecoveryManager.ApplicationCrashed">
            <summary>
            Fired when the application crashed.
            </summary>
        </member>
        <member name="T:CK.Windows.App.CrashLogWriter">
            <summary>
            Exposes a <see cref="T:System.IO.TextWriter"/> and safe write methods (as much as they can be).
            </summary>
        </member>
        <member name="M:CK.Windows.App.CrashLogWriter.WriteObjectToString(System.IO.TextWriter,System.Object,System.Boolean)">
            <summary>
            Writes the object and returns false if a new line has been added.
            </summary>
            <param name="isInline">True if there is something already written at the start of the line.</param>
            <returns>True if a new line MUST be added.</returns>
        </member>
        <member name="P:CK.Windows.App.CrashLogWriter.Writer">
            <summary>
            Gets the <see cref="T:System.IO.TextWriter"/> to write to.
            </summary>
        </member>
        <member name="P:CK.Windows.App.CrashLogWriter.IsValid">
            <summary>
            Gets whether the <see cref="P:CK.Windows.App.CrashLogWriter.Writer"/> is available. 
            </summary>
        </member>
        <member name="T:CK.Windows.App.CrashLogWindow">
            <summary>
            Interaction logic for CrashLogWindow.xaml
            </summary>
        </member>
        <member name="M:CK.Windows.App.CrashLogWindow.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:CK.Windows.App.CrashLogManager">
            <summary>
            Offers crash log management. 
            </summary>
        </member>
        <member name="M:CK.Windows.App.CrashLogManager.Initialize(System.String)">
            <summary>
            Must be called once and only once at the very beginning of the application.
            </summary>
            <param name="crashLogDirectory">The crash log directory to use.</param>
        </member>
        <member name="M:CK.Windows.App.CrashLogManager.HandleExistingCrashLogs">
            <summary>
            Displays a window that enables the user to upload any existing
            crash logs.
            </summary>
        </member>
        <member name="M:CK.Windows.App.CrashLogManager.CreateNew(System.String)">
            <summary>
            Obtains a new <see cref="T:CK.Windows.App.CrashLogWriter"/> to write crash information. 
            </summary>
            <param name="crashFilePrefix">Can be used to "scope" crash files. Defaults to "crashLog".</param>
            <returns>Always returns a non null CrashLogWriter (be it bound to a <see cref="F:System.IO.TextWriter.Null"/> if something really bad happens).</returns>
        </member>
        <member name="P:CK.Windows.App.CrashLogManager.CrashLogDirectory">
            <summary>
            Gets the crash log directory. Initialized by <see cref="M:CK.Windows.App.CrashLogManager.Initialize(System.String)"/>.
            </summary>
        </member>
        <member name="M:CK.Windows.App.CKAppParameters.#ctor(System.String,System.String)">
            <summary>
            Initializes a new <see cref="T:CK.Windows.App.CKAppParameters"/> with an application name and an optional subordinated name. 
            These are used to build the <see cref="P:CK.Windows.App.CKAppParameters.ApplicationDataPath"/> and <see cref="P:CK.Windows.App.CKAppParameters.CommonApplicationDataPath"/>.
            This constructor does no more than validating its parameters: it is totally safe and secure as long as <paramref name="appName"/> 
            and <see cref="!:distribName"/> are valid.
            </summary>
            <param name="appName">
            Name of the application (Civikey for instance for the Civikey application). 
            Must be an indentifier (no /, \ or other special characters in it: see <see cref="M:System.IO.Path.GetInvalidPathChars"/>).
            </param>
            <param name="distribName">Distribution name (can not be null nor empty). It must be an identifier just like <paramref name="appName"/>.</param>
        </member>
        <member name="M:CK.Windows.App.CKAppParameters.EnsureStandardPath(System.String)">
            <summary>
            Builds the path with <see cref="P:CK.Windows.App.CKAppParameters.AppName"/> and <see cref="P:CK.Windows.App.CKAppParameters.DistribName"/> and ensures that the folder exists.
            </summary>
            <param name="pathPrefix">
            Typically <see cref="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)"/> called 
            with <see cref="F:System.Environment.SpecialFolder.CommonApplicationData"/> or <see cref="F:System.Environment.SpecialFolder.ApplicationData"/>.
            </param>
            <returns>The path.</returns>
        </member>
        <member name="P:CK.Windows.App.CKAppParameters.ApplicationDataPath">
            <summary>
            Gets the full path of application-specific data repository, for the current user.
            Ends with <see cref="F:System.IO.Path.DirectorySeparatorChar"/>.
            The directory is created if it does not exist.
            </summary>
        </member>
        <member name="P:CK.Windows.App.CKAppParameters.CommonApplicationDataPath">
            <summary>
            Gets the full path of application-specific data repository, for all users.
            Ends with <see cref="F:System.IO.Path.DirectorySeparatorChar"/>.
            The directory is created if it does not exist.
            </summary>
        </member>
        <member name="P:CK.Windows.App.CKAppParameters.AppName">
            <summary>
            Gets the name of the application. Civikey-Standard for instance for the Civikey Standard application. 
            It is an indentifier (no /, \ or other special characters in it: see <see cref="M:System.IO.Path.GetInvalidPathChars"/>).
            </summary>
        </member>
        <member name="P:CK.Windows.App.CKAppParameters.DistribName">
            <summary>
            Gets the name of the distribution (can be not null nor empty).
            It is an identifier just like <see cref="P:CK.Windows.App.CKAppParameters.AppName"/>.
            </summary>
        </member>
        <member name="P:CK.Windows.App.CKAppParameters.GlobalMutexName">
            <summary>
            Unique name (Global\Install-AppName-DistribName) that identifies the application and that can be 
            used by installers to detect a running instance.
            </summary>
        </member>
        <member name="P:CK.Windows.App.CKAppParameters.LocalMutexName">
            <summary>
            Unique name (Local\AppName-DistribName) that identifies the application and that can 
            be used to avoid multiple application instance.
            </summary>
        </member>
        <member name="P:CK.Windows.App.CKAppParameters.UpdaterPath">
            <summary>
            Gets the full directory path to use for application updates. 
            </summary>
        </member>
        <member name="T:CK.Windows.App.Update.R">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CK.Windows.App.Update.R.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CK.Windows.App.Update.R.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:CK.Windows.App.Update.R.Update">
            <summary>
              Looks up a localized string similar to An update is available.
            </summary>
        </member>
        <member name="P:CK.Windows.App.Update.R.UpdateMessage">
            <summary>
              Looks up a localized string similar to A new version is ready to be installed, would you like to upgrade now?.
            </summary>
        </member>
        <member name="T:CK.Windows.App.UpdateManager">
            <summary>
            Very simple implementation of an update system that relies on external updater program.
            </summary>
        </member>
        <member name="P:CK.Windows.App.UpdateManager.UpdateDirectory">
            <summary>
            Gets the directory used to store and lookup for available updates. 
            </summary>
        </member>
    </members>
</doc>
