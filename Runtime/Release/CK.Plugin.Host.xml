<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CK.Plugin.Host</name>
    </assembly>
    <members>
        <member name="M:CK.Plugin.Hosting.ServiceHost.SetManualProxy(System.Type,CK.Plugin.Hosting.ServiceProxyBase)">
            <summary>
            For tests only.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceHost.LogMethodEnter(System.Reflection.MethodInfo,CK.Plugin.ServiceLogMethodOptions)">
            <summary>
            Called when a method is entered.
            </summary>
            <param name="m"></param>
            <param name="logOptions"></param>
            <returns></returns>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceHost.LogMethodError(CK.Plugin.Hosting.LogMethodEntry,System.Exception)">
            <summary>
            Called whenever an exception occured in a logged method.
            The existing entry may be closed or opened. If it is opened, we first
            send the EventCreated event for the error entry before sending 
            the EventCreated event for the method itself.
            We privilegiate here a hierarchical view: the error will be received before the end of the method.
            </summary>
            <param name="me">Existing entry.</param>
            <param name="ex">Exception raised.</param>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceHost.LogMethodError(System.Reflection.MethodInfo,System.Exception)">
            <summary>
            Called whenever an exception occured in a non logged method.
            </summary>
            <param name="m">The culprit method.</param>
            <param name="ex">The exception raised.</param>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceHost.LogMethodSuccess(CK.Plugin.Hosting.LogMethodEntry)">
            <summary>
            Called when a method with an opened entry succeeds.
            </summary>
            <param name="me"></param>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceHost.LogEventEnd(CK.Plugin.Hosting.LogEventEntry)">
            <summary>
            Called at the end of an event raising that have an existing opened log entry.
            Entries that have been created by <see cref="M:CK.Plugin.Hosting.ServiceHost.LogEventError(System.Reflection.EventInfo,System.Reflection.MethodInfo,System.Exception)"/> (because an exception 
            has been raised by at least one receiver) are not tracked.
            </summary>
            <param name="ee">The entry of the event that ended.</param>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceHost.LogEventError(CK.Plugin.Hosting.LogEventEntry,System.Reflection.MethodInfo,System.Exception)">
            <summary>
            Called whenever the recipient of an event raises an exception and the event log already exists. 
            This appends the error to the error list of the event entry.
            </summary>
            <param name="ee">Existing event log entry.</param>
            <param name="target">Culprit method.</param>
            <param name="ex">Exception raised by the culprit method.</param>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceHost.LogEventError(System.Reflection.EventInfo,System.Reflection.MethodInfo,System.Exception)">
            <summary>
            Called whenever the recipient of an event raises an exception and the event is not 
            yet logged (no <see cref="T:CK.Plugin.Hosting.LogEventEntry"/> exists). This creates the entry for the event 
            and the associated error.
            </summary>
            <param name="e">The reflected event info.</param>
            <param name="target">Culprit method.</param>
            <param name="ex">Exception raised by the culprit method.</param>
            <returns>The created event entry that holds the error.</returns>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceHost.LogEventNotRunningError(System.Reflection.EventInfo,System.Boolean)">
            <summary>
            Called when an event is raised by a stopped service and both <see cref="F:CK.Plugin.ServiceLogEventOptions.LogSilentEventRunningStatusError"/> 
            and <see cref="F:CK.Plugin.ServiceLogEventOptions.SilentEventRunningStatusError"/> are set.
            </summary>
        </member>
        <member name="T:CK.Plugin.R">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CK.Plugin.R.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CK.Plugin.R.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:CK.Plugin.R.DisabledAndRunningPluginsIntersect">
            <summary>
              Looks up a localized string similar to Disabled and Running list share {0} plugin(s)..
            </summary>
        </member>
        <member name="P:CK.Plugin.R.DisabledAndStoppedPluginsIntersect">
            <summary>
              Looks up a localized string similar to Disabled and Stopped list share {0} plugin(s)..
            </summary>
        </member>
        <member name="P:CK.Plugin.R.ExternalLogErrorMissException">
            <summary>
              Looks up a localized string similar to Missing Exception object in call to ExternalLogError..
            </summary>
        </member>
        <member name="P:CK.Plugin.R.PluginConfiguratorIsNull">
            <summary>
              Looks up a localized string similar to PluginRunner.PluginConfigurator must be not null..
            </summary>
        </member>
        <member name="P:CK.Plugin.R.PluginCreatorIsNull">
            <summary>
              Looks up a localized string similar to PluginRunner.PluginCreator must not be null..
            </summary>
        </member>
        <member name="P:CK.Plugin.R.PluginCreatorReturnedNull">
            <summary>
              Looks up a localized string similar to PluginCreator returned a null plugin for &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:CK.Plugin.R.ServiceIsAlreadyExternal">
            <summary>
              Looks up a localized string similar to Service &apos;{0}&apos; is already bound to an external implementation. Plugin &apos;{1}&apos; can not offer it..
            </summary>
        </member>
        <member name="P:CK.Plugin.R.ServiceIsPluginBased">
            <summary>
              Looks up a localized string similar to Service &apos;{0}&apos; is a dynamic service that is implemented by plugins. It can not be associated to an external implementation..
            </summary>
        </member>
        <member name="P:CK.Plugin.R.StoppedAndRunningPluginsIntersect">
            <summary>
              Looks up a localized string similar to Stopped and Running list share {0} plugin(s)..
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.LogMethodEntry.SetError(CK.Plugin.Hosting.LogMethodEntryError)">
            <summary>
            Setting the error closes the entry if it was opened.
            True is returned if the entry has been closed.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.PluginHost.FindPluginProxy(CK.Plugin.IPluginInfo)">
            <summary>
            Used for white tests only.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.PluginHost.Execute(System.Collections.Generic.IEnumerable{CK.Plugin.IPluginInfo},System.Collections.Generic.IEnumerable{CK.Plugin.IPluginInfo},System.Collections.Generic.IEnumerable{CK.Plugin.IPluginInfo})">
            <summary>
            Attempts to execute a plan.
            </summary>
            <param name="disabledPluginKeys">Plugins that must be disabled.</param>
            <param name="stoppedPluginKeys">Plugins that must be stopped.</param>
            <param name="runningPluginKeys">Plugins that must be running.</param>
            <returns>A <see cref="!:IExecutionPlanError"/> that details the error if any.</returns>
        </member>
        <member name="P:CK.Plugin.Hosting.PluginHost.PluginCreator">
            <summary>
            Gets or sets a function that is in charge of obtaining concrete plugin instances.
            Only the default constructor of the plugin must be called by this action.
            </summary>
        </member>
        <member name="P:CK.Plugin.Hosting.PluginHost.PluginConfigurator">
            <summary>
            Gets or sets a function called before the setup of each plugins to fill their edition properties.
            </summary>
        </member>
        <member name="P:CK.Plugin.Hosting.PluginHost.ServiceReferencesBinder">
            <summary>
            Gets or sets a function called after plugins that must stop or be disabled have actually been stopped or disabled
            and before start of (potentially newly loaded) plugins.
            </summary>
        </member>
        <member name="P:CK.Plugin.Hosting.PluginHost.LoadedPlugins">
            <summary>
            Gets the loaded plugins. This contains also the plugins that are currently disabled but have been loaded at least once.
            </summary>
        </member>
        <member name="P:CK.Plugin.Hosting.PluginHost.EventSender">
            <summary>
            Gets or sets the object that sends <see cref="!:IServiceHost.EventCreating"/> and <see cref="!:IServiceHost.EventCreated"/>.
            </summary>
        </member>
        <member name="T:CK.Plugin.Hosting.UseTheProxyBase">
            <summary>
            Fake internal class that forces the compiler to keep <see cref="T:CK.Plugin.Hosting.ServiceProxyBase"/> implementation.
            Without it, get_Status (for instance) is not ignored at compile time and hence, not defined when 
            the ServiceProxyBase is used as the base class by dynamic proxies.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceProxyBase.SetExternalImplementation(System.Object)">
            <summary>
            Currently, injection of external services must be totally independant of
            any Dynamic services: a Service is either a dynamic one, implemented by one (or more) plugin, 
            or an external one that is considered to be persistent and available.
            </summary>
            <param name="implementation"></param>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceProxyBase.GetLoggerForRunningCall(System.Int32,CK.Plugin.Hosting.LogMethodEntry@)">
            <summary>
            This method is called whenever a method not marked with <see cref="T:CK.Plugin.IgnoreServiceStoppedAttribute"/>
            is called. It throws a <see cref="T:CK.Plugin.ServiceStoppedException"/> if the service is stopped or disabled otherwise
            it returns the appropriate log configuration.
            </summary>
            <returns>The log configuration that must be used.</returns>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceProxyBase.GetLoggerForNotDisabledCall(System.Int32,CK.Plugin.Hosting.LogMethodEntry@)">
            <summary>
            Returns the appropriate log configuration after having checked that the dynamic service is not disabled.
            </summary>
            <returns>The log configuration that must be used.</returns>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceProxyBase.GetLoggerForAnyCall(System.Int32,CK.Plugin.Hosting.LogMethodEntry@)">
            <summary>
            Returns the appropriate log configuration without any runtime status checks.
            </summary>
            <returns>The log configuration that must be used.</returns>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceProxyBase.GetLoggerEventForRunningCall(System.Int32,CK.Plugin.Hosting.LogEventEntry@,CK.Plugin.ServiceLogEventOptions@)">
            <summary>
            This method is called whenever an event not marked with <see cref="T:CK.Plugin.IgnoreServiceStoppedAttribute"/>
            is raised. If the service is actually running, it does nothing and returns true.
            If the service is stopped or disabled it throws a <see cref="T:CK.Plugin.ServiceStoppedException"/> or returns false
            if <see cref="F:CK.Plugin.ServiceLogEventOptions.SilentEventRunningStatusError"/> is set: the event will not be raised and no exceptions will be
            thrown back to the buggy service.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.ServiceProxyBase.OnEventHandlingException(System.Int32,System.Reflection.MethodInfo,System.Exception,CK.Plugin.Hosting.LogEventEntry@)">
            <summary>
            This method is called when an event subscriber raises an exception while receiving the notification.
            By returning true, this methods silently swallow the exception. By returning false, the event dispatching
            is stoppped (remaining subscribers will not receive the event) and the plugin receives the exception (this
            corresponds to the standard behavior).
            </summary>
            <param name="iEventMRef">The index of the event info.</param>
            <param name="target">The called method that raised the exception.</param>
            <param name="ex">The exception.</param>
            <param name="ee">The log entry if it has been created. Will be created if needed.</param>
            <returns>True to silently swallow the exception.</returns>
        </member>
        <member name="F:CK.Plugin.Hosting.ProxyOptions.CatchExceptions">
            <summary>
            The proxified method traps any exception and routes it to <see cref="M:CK.Plugin.Hosting.ServiceProxyBase.OnCallException(System.Int32,System.Exception,CK.Plugin.Hosting.LogMethodEntry)"/>
            (or <see cref="M:CK.Plugin.Hosting.ServiceProxyBase.OnEventHandlingException(System.Int32,System.Reflection.MethodInfo,System.Exception,CK.Plugin.Hosting.LogEventEntry@)"/> during events raising).
            </summary>
        </member>
        <member name="F:CK.Plugin.Hosting.ProxyOptions.RuntimeCheckStatus">
            <summary>
            The proxified method will call <see cref="M:CK.Plugin.Hosting.ServiceProxyBase.GetLoggerForRunningCall(System.Int32,CK.Plugin.Hosting.LogMethodEntry@)"/>, <see cref="M:CK.Plugin.Hosting.ServiceProxyBase.GetLoggerForNotDisabledCall(System.Int32,CK.Plugin.Hosting.LogMethodEntry@)"/> 
            or <see cref="M:CK.Plugin.Hosting.ServiceProxyBase.GetLoggerForAnyCall(System.Int32,CK.Plugin.Hosting.LogMethodEntry@)"/> (or the 3 similar ones for events).
            </summary>
        </member>
        <member name="T:CK.Plugin.Hosting.IProxyDefinition">
            <summary>
            Defines the way a service proxy must be generated. 
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.IProxyDefinition.GetEventOptions(System.Reflection.EventInfo)">
            <summary>
            Gets for the given event, the options that drives code generation of the raising method.
            </summary>
            <param name="p">The event.</param>
            <returns>A set of options for the proxy.</returns>
        </member>
        <member name="M:CK.Plugin.Hosting.IProxyDefinition.GetPropertyMethodOptions(System.Reflection.PropertyInfo,System.Reflection.MethodInfo)">
            <summary>
            Gets for the given method property (getter or setter), the options that drives code generation of the method proxy.
            </summary>
            <param name="p">The property.</param>
            <param name="m">The method (can be the getter or the setter).</param>
            <returns>A set of options for the proxy.</returns>
        </member>
        <member name="M:CK.Plugin.Hosting.IProxyDefinition.GetMethodOptions(System.Reflection.MethodInfo)">
            <summary>
            Gets for the given method, the options that drives code generation of the method proxy.
            </summary>
            <param name="m">The method.</param>
            <returns>A set of options for the proxy.</returns>
        </member>
        <member name="P:CK.Plugin.Hosting.IProxyDefinition.TypeInterface">
            <summary>
            Gets the interface type that must be proxified.
            </summary>
        </member>
        <member name="P:CK.Plugin.Hosting.IProxyDefinition.ProxyBase">
            <summary>
            Gets a type that must be <see cref="T:CK.Plugin.Hosting.ServiceProxyBase"/> or a specialisation of it.
            </summary>
        </member>
        <member name="P:CK.Plugin.Hosting.IProxyDefinition.IsDynamicService">
            <summary>
            Gets whether the interface is a <see cref="T:CK.Plugin.IDynamicService"/> or not.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.PluginProxyBase.DisposeIfDisposable">
            <summary>
            Supports <see cref="T:System.IDisposable"/> implementation. If the real plugin does not implement it, nothing is done and 
            the current reference instance is kept (it will be reused).
            If IDisposable is implemented, a call to Dispose may throw an exception (it should be handled above), but the _instance 
            reference is set to null: a new object will always have to be created if the plugin needs to be started again.
            </summary>
        </member>
        <member name="P:CK.Plugin.Hosting.PluginProxyBase.Service">
            <summary>
            Gets the implemented service.
            </summary>
        </member>
        <member name="T:CK.Plugin.Hosting.LogMethodEntryError">
            <summary>
            Used for error that occured in a logged method: the <see cref="T:CK.Plugin.Hosting.LogMethodEntry"/> already exists.
            </summary>
        </member>
        <member name="T:CK.Plugin.Hosting.LogMethodError">
            <summary>
            Used for error that occured in a non-logged method.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.ProxyFactory.CreateProxy(CK.Plugin.Hosting.IProxyDefinition)">
            <summary>
            Creates a proxyfied interface according to the given definition.
            </summary>
            <param name="definition">Definition of the proxy to build.</param>
            <param name="initialImplementation">Optional first and available implementation.</param>
            <returns></returns>
        </member>
        <member name="M:CK.Plugin.Hosting.ProxyFactory.ProxyGenerator.RegisterRef``1(System.Collections.Generic.List{``0},``0)">
            <summary>
            Registers an index to a <see cref="T:System.Reflection.MemberInfo"/>.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.ProxyFactory.ProxyGenerator.GenerateInterceptor(System.Reflection.MethodInfo,CK.Plugin.Hosting.ProxyOptions)">
            <summary>
            Generates the exact signature and the code that relays the call 
            to the _impl corresponding method.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.ProxyFactory.ProxyGenerator.CreateInterfaceMethodBuilder(System.Reflection.Emit.TypeBuilder,System.Reflection.MethodInfo,System.Type[]@)">
            <summary>
            Creates a <see cref="T:System.Reflection.Emit.MethodBuilder"/> for a given method. 
            Handles generic parameters on the method.
            </summary>
            <param name="typeBuilder"></param>
            <param name="m"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:CK.Plugin.Hosting.LogEventEntry.InitError(System.Int32,System.Int32,System.Reflection.EventInfo,CK.Plugin.Hosting.LogEventEntryError)">
            <summary>
            Initializes the entry as an hidden error head (the first time an error occcurs and no event entry is created
            for the event). This entry is not visible (it is not emitted as a log event), it is here to handle the 
            potential list of errors that the event will raise.
            </summary>
            <param name="lsn"></param>
            <param name="depth"></param>
            <param name="e"></param>
            <param name="firstOne"></param>
        </member>
        <member name="T:CK.Plugin.Hosting.SimpleServiceHostConfiguration">
            <summary>
            Simple dictionary based implementation of <see cref="T:CK.Plugin.IServiceHostConfiguration"/>.
            </summary>
        </member>
        <member name="M:CK.Plugin.Hosting.SimpleServiceHostConfiguration.GetOptions(System.Reflection.MethodInfo)">
            <summary>
            Returns the <see cref="T:CK.Plugin.ServiceLogMethodOptions"/> for the given method.
            </summary>
            <param name="m">Method for which options should be obtained.</param>
            <returns>Configuration for the method.</returns>
        </member>
        <member name="M:CK.Plugin.Hosting.SimpleServiceHostConfiguration.GetOptions(System.Reflection.EventInfo)">
            <summary>
            Returns the <see cref="T:CK.Plugin.ServiceLogEventOptions"/> for the given event.
            </summary>
            <param name="e">Event for which options should be obtained.</param>
            <returns>Configuration for the event.</returns>
        </member>
    </members>
</doc>
