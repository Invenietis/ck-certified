using System;
using System.Windows.Input;
using System.Diagnostics;

namespace CK.WPF.Controls
{
    /// <summary>
    /// A command whose sole purpose is to relay its functionality to other
    /// objects by invoking delegates. The default return value for the CanExecute method is 'true'.
    /// From http://mvvmfoundation.codeplex.com/ open source project.
    /// </summary>
    /// <remarks>
    /// CanExecuteChanged and memory leaks.
    /// <para>
    /// This class uses the centralized <see cref="CommandManager.RequerySuggested"/> to implement <see cref="CanExecuteChanged"/> event
    /// when a <see cref="CanExecute"/> delegate is provided.
    /// </para>
    /// <para>
    /// Apparently, WPF expects this event to be implemented as a weak event. That means, the event should use a List&lt;WeakReference&gt; for 
    /// the delegates, so that objects don’t have to unregister (because they don’t!).
    /// </para>
    /// <para>
    /// Interestingly, this means a WeakReference to the delegate, not to the listening object – the listening object 
    /// must keep a reference to its own delegate instance so that the delegate doesn’t get garbage collected even 
    /// though the listening object is still reachable.
    /// CommandManager.RequerySuggested is such a weak event, so code below works fine.
    /// </para>
    /// The default interface implementation generated by VS – a default C# event (“public EventHandler CanExecuteChanged;”) – will cause a memory leak!
    /// So basically, there are only two easy options:
    /// <list type="">
    /// <item>
    /// If CanExecute never changes and you don’t intend to fire the event, then don’t use a default event, use an event that doesn’t store the delegates.
    /// <c>public event EventHandler CanExecuteChanged { add { } remove { } }</c>
    /// </item>
    /// <item>2) If CanExecute changes, use the CommandManager.</item>
    /// </list>
    /// </remarks>
    public class SimpleCommand : ICommand
    {
        readonly Action _execute;
        readonly Func<bool> _canExecute;
        
        /// <summary>
        /// Creates a new command that can always execute.
        /// </summary>
        /// <param name="execute">The execution logic.</param>
        public SimpleCommand( Action execute )
            : this( execute, null )
        {
        }

        /// <summary>
        /// Creates a new command.
        /// </summary>
        /// <param name="execute">The execution logic.</param>
        /// <param name="canExecute">The execution status logic.</param>
        public SimpleCommand( Action execute, Func<bool> canExecute )
        {
            if( execute == null )
                throw new ArgumentNullException( "execute" );

            _execute = execute;
            _canExecute = canExecute;
        }

        [DebuggerStepThrough]
        public bool CanExecute( object parameter )
        {
            return _canExecute == null ? true : _canExecute();
        }

        public event EventHandler CanExecuteChanged
        {
            add
            {
                if( _canExecute != null )
                    CommandManager.RequerySuggested += value;
            }
            remove
            {
                if( _canExecute != null )
                    CommandManager.RequerySuggested -= value;
            }
        }

        public void Execute( object parameter )
        {
            _execute();
        }

    }

    /// <summary>
    /// A command whose sole purpose is to relay its functionality to other
    /// objects by invoking delegates. The default return value for the CanExecute method is 'true'.
    /// From http://mvvmfoundation.codeplex.com/ open source project.
    /// </summary>
    public class SimpleCommand<T> : ICommand
    {
        readonly Action<T> _execute;
        readonly Func<T,bool> _canExecute;

        public SimpleCommand( Action<T> execute )
            : this( execute, null )
        {
        }

        /// <summary>
        /// Creates a new command.
        /// </summary>
        /// <param name="execute">The execution logic.</param>
        /// <param name="canExecute">The execution status logic.</param>
        public SimpleCommand( Action<T> execute, Func<T,bool> canExecute )
        {
            if( execute == null )
                throw new ArgumentNullException( "execute" );

            _execute = execute;
            _canExecute = canExecute;
        }

        [DebuggerStepThrough]
        public bool CanExecute( object parameter )
        {
            return _canExecute == null ? true : _canExecute( (T)parameter );
        }

        public event EventHandler CanExecuteChanged
        {
            add
            {
                if( _canExecute != null )
                    CommandManager.RequerySuggested += value;
            }
            remove
            {
                if( _canExecute != null )
                    CommandManager.RequerySuggested -= value;
            }
        }

        public void Execute( object parameter )
        {
            _execute( (T)parameter );
        }

    }
    
}
