<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CK.Core</name>
    </assembly>
    <members>
        <member name="T:CK.Core.IReadOnlyList`1">
            <summary>
            Represents a read only collection of objects that can be individually accessed by index.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="T:CK.Core.IReadOnlyCollection`1">
            <summary>
            Represents a generic read only collections of objects.
            </summary>
            <typeparam name="T">The type of the elements in the collection.</typeparam>
        </member>
        <member name="M:CK.Core.IReadOnlyCollection`1.Contains(System.Object)">
            <summary>
            Determines whether collection contains a specific value.
            </summary>
            <param name="item">The object to find in the collecion.</param>
            <returns>True if item is found in the collection; otherwise, false.</returns>
        </member>
        <member name="P:CK.Core.IReadOnlyCollection`1.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
        </member>
        <member name="M:CK.Core.IReadOnlyList`1.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in the list.
            </summary>
            <param name="item">The object to locate in the list.</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="P:CK.Core.IReadOnlyList`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="index"/> is not a valid index in the list.</exception>
        </member>
        <member name="T:CK.Core.ReadOnlyListMono`1">
            <summary>
            Implements a mono element <see cref="T:CK.Core.IReadOnlyList`1"/>.
            </summary>
            <typeparam name="T">The type of element in the read only list.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyListMono`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="val">Element contained by the <see cref="T:CK.Core.ReadOnlyListMono`1"/></param>
        </member>
        <member name="M:CK.Core.ReadOnlyListMono`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the given item.
            </summary>
            <param name="item">Item to find</param>
            <returns>Index of the item, 0 or -1 if it is not found</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListMono`1.Contains(System.Object)">
            <summary>
            Gets if the given item is contained into the list.
            </summary>
            <param name="item">Item to find</param>
            <returns>True if the item is found, false otherwise.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListMono`1.GetEnumerator">
            <summary>
            Gets the underlying enumerator, <see cref="T:CK.Core.EnumMono`1"/> actually.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListMono`1.Item(System.Int32)">
            <summary>
            Gets the item at the given index.
            </summary>
            <param name="i">Index of the item to find.</param>
            <returns>Found item at the index. If the index is not 0 an <see cref="T:System.IndexOutOfRangeException"/> will be thrown.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListMono`1.Count">
            <summary>
            Gets the count of the list, 1 in all cases.
            </summary>
        </member>
        <member name="T:CK.Core.EnumMono`1">
            <summary>
            Defines an optimized <see cref="T:System.Collections.Generic.IEnumerator`1"/> that contains
            only one element.
            </summary>
        </member>
        <member name="M:CK.Core.EnumMono`1.#ctor(`0)">
            <summary>
            Constructor
            </summary>
            <param name="val">Unique object that will be contained into the <see cref="T:CK.Core.EnumMono`1"/></param>
        </member>
        <member name="M:CK.Core.EnumMono`1.Dispose">
            <summary>
            Dispose the <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.EnumMono`1.MoveNext">
            <summary>
            Move to the next element.
            </summary>
            <returns>True if position is equal to 0, false otherwise</returns>
        </member>
        <member name="M:CK.Core.EnumMono`1.Reset">
            <summary>
            Reset the enumerator.
            </summary>
        </member>
        <member name="P:CK.Core.EnumMono`1.Current">
            <summary>
            Gets the strongly typed element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="T:CK.Core.EnumerableAdapter`2">
            <summary>
            Wraps a <see cref="T:System.Collections.IEnumerable"/> of a <typeparamref name="TOuter"/> type around a <see cref="T:System.Collections.IEnumerable"/>
            of <typeparamref name="TInner"/> where the latter is a specialization of the former.
            This is a special case of the <see cref="T:CK.Core.EnumerableConverter`2"/> where the conversion function is a simple cast
            between the two types.
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of enumerated objects.</typeparam>
        </member>
        <member name="T:CK.Core.Wrapper`1">
            <summary>
            Simple wrapper: <see cref="P:CK.Core.Wrapper`1.Inner"/> property is the wrapped object.
            </summary>
            <typeparam name="T">Type of wrapped object.</typeparam>
        </member>
        <member name="M:CK.Core.Wrapper`1.#ctor(`0)">
            <summary>
            Initializes a wrapper around an object.
            </summary>
            <param name="inner">Wrapped object.</param>
        </member>
        <member name="M:CK.Core.Wrapper`1.CreateEnumerator``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.IEnumerator"/> on a <see cref="T:System.Collections.IEnumerable"/> of specialized entities.
            </summary>
            <typeparam name="TInner">Actual entity.</typeparam>
            <param name="e">Source enumerable.</param>
            <returns>An enumerator for the more abstract type.</returns>
        </member>
        <member name="M:CK.Core.Wrapper`1.CreateEnumerator``1(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,`0})">
            <summary>
            Creates a <see cref="T:System.Collections.IEnumerator"/> on a <see cref="T:System.Collections.IEnumerable"/> of another type.
            </summary>
            <typeparam name="TInner">Actual entity.</typeparam>
            <param name="e">Source enumerable.</param>
            <param name="converter">Converter from <typeparamref name="TInner"/> to <typeparamref name="T"/>.</param>
            <returns>An enumerator for the more abstract type.</returns>
        </member>
        <member name="P:CK.Core.Wrapper`1.Inner">
            <summary>
            Gets the wrapped object.
            </summary>
        </member>
        <member name="M:CK.Core.EnumerableAdapter`2.#ctor(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Initializes a new adapter.
            </summary>
            <param name="c">Enumerable to wrap.</param>
        </member>
        <member name="M:CK.Core.EnumerableAdapter`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through this enumerable.
            </summary>
            <returns>A IEnumerator that can be used to iterate through this enumerable.</returns>
        </member>
        <member name="T:CK.Core.EnumerableAdapter`2.EnumeratorAdapter">
            <summary>
            Internal implementation of the enumerator.
            </summary>
        </member>
        <member name="T:CK.Core.DictionaryExtension">
            <summary>
            Provides extension methods for <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetValueWithDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            Gets the value associated with the specified key if it exists otherwise returns the <paramref name="defaultValue"/>.
            </summary>
            <param name="that">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">Default value to use if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the <paramref name="defaultValue"/>. 
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetValueWithDefaultFunc``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Gets the value associated with the specified key if it exists otherwise calls the <paramref name="defaultValue"/> function.
            </summary>
            <param name="that">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="defaultValue">A delegate that will be called if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the result 
            of the <paramref name="defaultValue"/> delegate.
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.GetOrSet``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Gets the value associated with the specified key if it exists otherwise calls the <paramref name="createValue"/> function
            and adds the newly obtained value into the dictionary.
            </summary>
            <param name="that">This generic IDictionary.</param>
            <param name="key">The key whose value to get.</param>
            <param name="createValue">A delegate that will be called if the key does not exist.</param>
            <returns>
            The value associated with the specified key, if the key is found; otherwise, the result 
            of the <paramref name="createValue"/> delegate (this result has been added to the dictionary).
            </returns>
        </member>
        <member name="M:CK.Core.DictionaryExtension.AddRange``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Adds the content of a dictionary to this <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="that">This generic IDictionary.</param>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Collections.Generic.KeyValuePair`2"/> from which content will be copied.</param>
        </member>
        <member name="T:CK.Core.ISimpleServiceContainer">
            <summary>
            Defines a container for services.
            </summary>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})">
            <summary>
            Registers a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Object,System.Action{System.Object})">
            <summary>
            Registers a service with its implementation (and an optional callback that will be called when the service will be removed).
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)">
            <summary>
            Unregisters a service. Can be called even if the service does not exist.
            The service is first removed and then the OnRemove associated action is called if it exists:
            this enables OnRemove action to be bound to a method that safely calls back this Remove method.
            </summary>
            <param name="serviceType">Service type to unregister.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.Clear">
            <summary>
            Unregisters all the services. Any "on remove" actions are executed.
            </summary>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ISimpleServiceContainer.AddDisabled(System.Type)">
            <summary>
            Disables a service: null will always be returned by this <see cref="M:System.IServiceProvider.GetService(System.Type)"/>
            regardless of any fallbacks that may exist for this container.
            </summary>
            <remarks>
            This is not the same as calling <see cref="M:CK.Core.ISimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})"/> with a null instance. A null instance for a service (a callback that always returns null)
            is nearly the same as calling <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>: any fallbacks (to a base <see cref="T:System.IServiceProvider"/> for example) can occur.
            This is stronger since this must prevent fallbacks.
            </remarks>
            <param name="serviceType">Service type to disable. It must not already exist in this container otherwise an exception is thrown.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.MissingDisposeCallSentinel">
             <summary>
             Helper class that helps detecting missing calls to <see cref="M:System.IDisposable.Dispose"/>.
             </summary>
             <example>
             Sample code for a simple class (if unmanaged resources are involved or may be involved by the disposable object,
             the standard Dispose(bool disposing) pattern must be implemented.
             <code>
             class DisposableClassDebug : IDisposable
             {
             #if DEBUG
                 MissingDisposeCallSentinel _sentinel = new MissingDisposeCallSentinel();
                 ~DisposableClassDebug()
                 {
                     MissingDisposeCallSentinel.RegisterMissing( _sentinel );
                 }
             #endif
            
                 public void Dispose()
                 {
             #if DEBUG
                     _sentinel = null;
                     GC.SuppressFinalize( this );
             #endif
                 }
             }
             </code> 
             </example>
        </member>
        <member name="F:CK.Core.MissingDisposeCallSentinel.Time">
            <summary>
            Creation time of the <see cref="T:System.IDisposable"/> object.
            </summary>
        </member>
        <member name="F:CK.Core.MissingDisposeCallSentinel.ThreadId">
            <summary>
            Thread identifier that created the <see cref="T:System.IDisposable"/> object.
            </summary>
        </member>
        <member name="F:CK.Core.MissingDisposeCallSentinel.StackTrace">
            <summary>
            Stack trace of the <see cref="T:System.IDisposable"/> object creation.
            </summary>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.MissingDisposeCallSentinel"/>. 
            Should be called during a field initializer in the <see cref="T:System.IDisposable"/> object.
            </summary>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.ToString">
            <summary>
            Overriden to return <see cref="F:CK.Core.MissingDisposeCallSentinel.Time"/>, <see cref="F:CK.Core.MissingDisposeCallSentinel.ThreadId"/> and <see cref="F:CK.Core.MissingDisposeCallSentinel.StackTrace"/>.
            </summary>
            <returns>Creation time information.</returns>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.Clear">
            <summary>
            Clears all registered <see cref="T:CK.Core.MissingDisposeCallSentinel"/>
            This method is thread safe.
            </summary>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.DumpMissing">
            <summary>
            Gets a string with missing dispose information. Null if <see cref="P:CK.Core.MissingDisposeCallSentinel.HasMissingDisposeCall"/> is false.
            This method is thread safe.
            </summary>
            <returns>Number of missing dispose and related information to each of them.</returns>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.RegisterMissing(CK.Core.MissingDisposeCallSentinel)">
            <summary>
            Registers a sentinel. Should be called from the <see cref="T:System.IDisposable"/> object finalizer.
            This method is thread safe.
            </summary>
            <param name="s">A <see cref="T:CK.Core.MissingDisposeCallSentinel"/>. Can be null (to avoid the test in the caller).</param>
        </member>
        <member name="M:CK.Core.MissingDisposeCallSentinel.DebugCheckMissing(System.Action{System.String})">
            <summary>
            DEBUG must be active (at the caller level). Typical use: <code>DebugCheckMissing( s =&gt; Debug.Fail( s ) );</code>.
            (<see cref="M:System.Diagnostics.Debug.Fail(System.String)"/> can not be used as a delegate because of its own <see cref="T:System.Diagnostics.ConditionalAttribute"/>.)
            Triggers <see cref="M:System.GC.Collect(System.Int32)"/> to detect missing dispose calls.
            </summary>
        </member>
        <member name="P:CK.Core.MissingDisposeCallSentinel.Missing">
            <summary>
            Gets all the <see cref="T:CK.Core.MissingDisposeCallSentinel"/> that been registered via <see cref="M:CK.Core.MissingDisposeCallSentinel.RegisterMissing(CK.Core.MissingDisposeCallSentinel)"/>.
            This method is thread safe.
            </summary>
        </member>
        <member name="P:CK.Core.MissingDisposeCallSentinel.HasMissingDisposeCall">
            <summary>
            True if any missing call to dispose have been detected.
            This method is thread safe.
            </summary>
        </member>
        <member name="T:CK.Core.IActionSequence">
            <summary>
            Provides a way to stack <see cref="T:System.Action"/>s and to defer their execution. 
            This interface only defines append behavior.
            </summary>
        </member>
        <member name="M:CK.Core.IActionSequence.Append(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Appends an event raising.
            </summary>
            <param name="e">The <see cref="T:System.EventHandler"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Appends an event raising.
            </summary>
            <typeparam name="T">Must be a class that inherits from <see cref="T:System.EventArgs"/>.</typeparam>
            <param name="e">The <see cref="T:System.EventHandler`1"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append(System.Action)">
            <summary>
            Appends an action (without parameters).
            </summary>
            <param name="action">No parameter <see cref="T:System.Action"/> delegate.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append``1(System.Action{``0},``0)">
            <summary>
            Appends an action (with one parameter).
            </summary>
            <param name="action">One parameter <see cref="T:System.Action"/> delegate.</param>
            <param name="parameter">Action parameter.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Appends an action (with two parameters).
            </summary>
            <param name="action">Two parameters <see cref="T:System.Action"/> delegate.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Append``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Appends an action (with three parameters).
            </summary>
            <param name="action">Three parameters <see cref="T:System.Action"/> delegate.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
            <param name="p3">Third action parameter.</param>
        </member>
        <member name="M:CK.Core.IActionSequence.Clear">
            <summary>
            Removes all recorded actions.
            </summary>
        </member>
        <member name="P:CK.Core.IActionSequence.ReadOnly">
            <summary>
            Gets a boolean that states whether this sequence is read-only. 
            When a sequence is read-only, any attempt to append an action is an error (an exception must be thrown).
            Defaults to false.
            </summary>
        </member>
        <member name="T:CK.Core.XmlExtension">
            <summary>
            Extension methods for <see cref="T:System.Xml.XmlReader"/> and <see cref="T:System.Xml.XmlWriter"/>
            classes.
            </summary>
        </member>
        <member name="M:CK.Core.XmlExtension.ReadEndElement(System.Xml.XmlReader,System.String)">
            <summary>
            Little helper that only increases source code readability: it calls <see cref="M:System.Xml.XmlReader.ReadEndElement"/>
            that checks the name of the closing element. This "helper" forces the developper to explicitely
            write this name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the closing element.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeBoolean(System.Xml.XmlReader,System.String,System.Boolean)">
            <summary>
            Gets a boolean attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeDateTime(System.Xml.XmlReader,System.String,System.DateTime)">
            <summary>
            Gets a <see cref="T:System.DateTime"/> attribute by name. It uses <see cref="F:System.Xml.XmlDateTimeSerializationMode.RoundtripKind"/>.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeVersion(System.Xml.XmlReader,System.String,System.Version)">
            <summary>
            Gets a <see cref="T:System.Version"/> attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeInt(System.Xml.XmlReader,System.String,System.Int32)">
            <summary>
            Gets an <see cref="T:System.Int32"/> attribute by name.
            </summary>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist.</param>
        </member>
        <member name="M:CK.Core.XmlExtension.GetAttributeEnum``1(System.Xml.XmlReader,System.String,``0)">
            <summary>
            Gets an enum value.
            </summary>
            <typeparam name="T">Type of the enum. There is no way (in c#) to constraint the type to Enum - nor to Delegate, this is why 
            the constraint restricts only the type to be a value type.</typeparam>
            <param name="r">This <see cref="T:System.Xml.XmlReader"/>.</param>
            <param name="name">Name of the attribute.</param>
            <param name="defaultValue">Default value if the attribute does not exist or can not be parsed.</param>
            <returns></returns>
        </member>
        <member name="T:CK.Core.WeakReference`1">
            <summary>
            A generic weak reference, which references an object while still allowing  
            that object to be reclaimed by garbage collection.   
            </summary>   
            <typeparam name="T">The type of the object that is referenced.</typeparam>
            <remarks>
            An implicit cast exists from <typeparamref name="T"/> to <see cref="T:CK.Core.WeakReference`1"/> 
            BUT NOT the opposite, and it is asolutely normal!
            </remarks>
        </member>
        <member name="M:CK.Core.WeakReference`1.#ctor(`0)">
            <summary>       
            Initializes a new instance of a weak reference to 
            the specified object.       
            </summary>       
            <param name="target">The object to reference.</param>       
        </member>
        <member name="M:CK.Core.WeakReference`1.#ctor(`0,System.Boolean)">
            <summary>       
            Initializes a new instance of the WeakReference{T} class, referencing
            the specified object and using the specified resurrection tracking.
            </summary>       
            <param name="target">An object to track.</param>
            <param name="trackResurrection">Indicates when to stop tracking the object. If true, the object is tracked
            after finalization; if false, the object is only tracked until finalization.</param>
        </member>
        <member name="M:CK.Core.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Required serialization constructor.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/>.</param>
        </member>
        <member name="M:CK.Core.WeakReference`1.op_Implicit(`0)~CK.Core.WeakReference{`0}">
            <summary>
            Casts an object of the type T to a weak reference of T.
            </summary>
        </member>
        <member name="P:CK.Core.WeakReference`1.Target">
            <summary>
            Gets or sets the object (the target) referenced by this weak reference.
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyCollectionOnICollection`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.ICollection`1"/> object to the <see cref="T:CK.Core.IReadOnlyCollection`1"/> interface.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnICollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionOnICollection`1"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnICollection`1.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnICollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionOnICollection`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyCollectionOnHashSet`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.HashSet`1"/> object to the <see cref="T:CK.Core.IReadOnlyCollection`1"/> interface.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnHashSet`1.#ctor(System.Collections.Generic.HashSet{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionOnICollection`1"/> around a <see cref="T:System.Collections.Generic.HashSet`1"/>.
            </summary>
            <param name="c">Hash set to wrap.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnHashSet`1.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionOnHashSet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>A IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionOnHashSet`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.IFluentInterface">
            <summary>
            Helper interface used to hide the base <see cref="T:System.Object"/> members from the fluent API to make 
            for much cleaner Visual Studio intellisense experience. (Excellent idea borrowed from EntLib.)
            </summary>
        </member>
        <member name="M:CK.Core.IFluentInterface.GetType">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.GetHashCode">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.ToString">
            <summary/>
        </member>
        <member name="M:CK.Core.IFluentInterface.Equals(System.Object)">
            <summary/>
        </member>
        <member name="T:CK.Core.ReadOnlyCollectionTypeAdapter`2">
            <summary>
            Wraps a <see cref="T:CK.Core.IReadOnlyCollection`1"/> of a <typeparamref name="TOuter"/> type around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            of <typeparamref name="TInner"/> (the <see cref="P:CK.Core.ReadOnlyCollectionTypeAdapter`2.Inner"/> collection).
            Will be obsolete in .Net framework 4.0 (this is only here to support covariance).
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of the objects contained in the <see cref="P:CK.Core.ReadOnlyCollectionTypeAdapter`2.Inner"/> collection.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionTypeAdapter`2.#ctor(System.Collections.Generic.ICollection{`1})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionAdapter`2"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionTypeAdapter`2.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionTypeAdapter`2.Inner">
            <summary>
            Wrapped collection.
            </summary>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionTypeAdapter`2.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyCollectionAdapter`2">
            <summary>
            Obsolete, use <see cref="T:CK.Core.ReadOnlyCollectionTypeAdapter`2"/> instead.
            </summary>
            <typeparam name="TOuter"></typeparam>
            <typeparam name="TInner"></typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionAdapter`2.#ctor(System.Collections.Generic.ICollection{`1})">
            <summary>
            Constructor
            </summary>
            <param name="c"></param>
        </member>
        <member name="T:CK.Core.EnumerableConverter`2">
            <summary>
            Wraps a <see cref="T:System.Collections.IEnumerable"/> of a <typeparamref name="TOuter"/> type around a <see cref="T:System.Collections.IEnumerable"/>
            of <typeparamref name="TOuter"/> thanks to a conversion function.
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of enumerated objects.</typeparam>
        </member>
        <member name="M:CK.Core.EnumerableConverter`2.#ctor(System.Collections.Generic.IEnumerable{`1},System.Converter{`1,`0})">
            <summary>
            Initializes a new adapter.
            </summary>
            <param name="c">Enumerable to wrap.</param>
            <param name="converter">Conversion function to apply.</param>
        </member>
        <member name="M:CK.Core.EnumerableConverter`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through this enumerable.
            </summary>
            <returns>A IEnumerator that can be used to iterate through this enumerable.</returns>
        </member>
        <member name="P:CK.Core.EnumerableConverter`2.Converter">
            <summary>
            Gets the converter associated to this <see cref="T:CK.Core.EnumerableConverter`2"/>.
            </summary>
        </member>
        <member name="T:CK.Core.EnumerableConverter`2.EnumeratorAdapter">
            <summary>
            Internal implementation of the enumerator.
            </summary>
        </member>
        <member name="T:CK.Core.CKException">
            <summary>
            Basic <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String,System.Object[])">
            <summary>
            Constructor
            </summary>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:CK.Core.CKException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>
            Constructor
            </summary>
            <param name="innerException"></param>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="T:CK.Core.InvalidFileException">
            <summary>
            <see cref="T:CK.Core.CKException"/> raised when something in a file goes wrong.
            </summary>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Protected constructor, that will intialize the <see cref="T:CK.Core.CKException"/> with
            a <see cref="T:System.Runtime.Serialization.SerializationInfo"/> and a <see cref="T:System.Runtime.Serialization.StreamingContext"/>.
            </summary>
            <param name="info">Given to initialize the <see cref="T:CK.Core.CKException"/>.</param>
            <param name="context">Given to initialize the <see cref="T:CK.Core.CKException"/>.</param>
        </member>
        <member name="M:CK.Core.InvalidFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Gets the object data.
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="filePath"></param>
            <param name="message"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.String,System.String,System.Object[])">
            <summary>
            Constructor
            </summary>
            <param name="filePath"></param>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="filePath"></param>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:CK.Core.InvalidFileException.#ctor(System.String,System.Exception,System.String,System.Object[])">
            <summary>
            Constructor
            </summary>
            <param name="filePath"></param>
            <param name="innerException"></param>
            <param name="messageFormat"></param>
            <param name="args"></param>
        </member>
        <member name="P:CK.Core.InvalidFileException.FilePath">
            <summary>
            Gets the path of the current file.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.IUniqueId"/> interface.
            </summary>
        </member>
        <member name="T:CK.Core.IUniqueId">
            <summary>
            Minimal interface that enables any type (specially reference type) to
            expose a <see cref="T:System.Guid"/>.
            </summary>
        </member>
        <member name="P:CK.Core.IUniqueId.UniqueId">
            <summary>
            Gets the unique identifier associated to this object.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.IUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.IUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a marker.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleUniqueId.EmptyArray">
            <summary>
            Empty array of <see cref="T:CK.Core.IUniqueId"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleUniqueId.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleUniqueId"/> where its <see cref="P:CK.Core.SimpleUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
        </member>
        <member name="M:CK.Core.SimpleUniqueId.#ctor(System.Guid)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleUniqueId"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleUniqueId.UniqueId"/>.</param>
        </member>
        <member name="P:CK.Core.SimpleUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="T:CK.Core.ISimpleTypeFinder">
            <summary>
            This simple interface allows to resolve types from names.
            </summary>
            <remarks>
            Types mapping is an option that should be used with care.    
            </remarks>
        </member>
        <member name="M:CK.Core.ISimpleTypeFinder.MapType(System.String)">
            <summary>
            Gets an (optionnal) mapping from any name of a type to the actual
            assembly qualified name that must be used for it.
            This function MUST be idempotent (ie. MapType( MapType(x) ) == MapType(x) whatever x is).
            Its default implementation is simply to return its parameter unchanged (no mapping).
            </summary>
            <param name="externalName">The assembly qualified name of a type.</param>
            <returns>The assembly qualified name (that <see cref="M:CK.Core.ISimpleTypeFinder.ResolveType(System.String,System.Boolean)"/> can use) of the type to use.</returns>
        </member>
        <member name="M:CK.Core.ISimpleTypeFinder.ResolveType(System.String,System.Boolean)">
            <summary>
            First calls <see cref="M:CK.Core.ISimpleTypeFinder.MapType(System.String)"/> and then resolves the <see cref="T:System.Type"/> from the mapped string.
            If <paramref name="throwOnError"/> is true, a <see cref="T:System.TypeLoadException"/> will be fired if the resolution fails.
            </summary>
            <param name="externalName">Assembly qualified name of the type</param>
            <param name="throwOnError">
            True to ALWAYS throw a <see cref="T:System.TypeLoadException"/> if the type is not found.
            False prevents any exception to be thrown and simply returns null.
            </param>
            <returns>The type or null if not found and <paramref name="throwOnError"/> is false.</returns>
            <exception cref="T:System.TypeLoadException">
            When <paramref name="throwOnError"/> is true, always throws this kind of exception.
            The original error (not a <see cref="T:System.TypeLoadException"/>) is available in the <see cref="P:System.Exception.InnerException"/>.
            </exception>
        </member>
        <member name="T:CK.Core.SimpleServiceContainer">
            <summary>
            Service container (that is a <see cref="T:System.IServiceProvider"/>) subordinated to an optional base IServiceProvider 
            that acts as a fallback if the service is not found at this level.
            Service creation may be deferred thanks to callback registration and an optional remove callback can be registered
            with each entry.
            </summary>
            <remarks>
            This container is registered as the service associated to <see cref="T:System.IServiceProvider"/> and <see cref="T:CK.Core.ISimpleServiceContainer"/>
            thanks to the overridable <see cref="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)"/>. This method may be overriden to return other built-in services: these services
            take precedence over the registered services.
            </remarks>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleServiceContainer"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.#ctor(System.IServiceProvider)">
            <summary>
            Initializes a new <see cref="T:CK.Core.SimpleServiceContainer"/> with a <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/>.
            </summary>
            <param name="baseProvider">Base <see cref="T:System.IServiceProvider"/> provider.</param>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})">
            <summary>
            Registers a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Object,System.Action{System.Object})">
            <summary>
            Registers a service with its implementation (and an optional callback that will be called when the service will be removed).
            </summary>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.AddDisabled(System.Type)">
            <summary>
            Disables a service: null will always be returned by this <see cref="M:System.IServiceProvider.GetService(System.Type)"/>
            regardless of any fallbacks from <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/>. 
            Direct services returned by <see cref="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)"/> can not be disabled.
            </summary>
            <remarks>
            This is not the same as calling <see cref="M:CK.Core.SimpleServiceContainer.Add(System.Type,System.Func{System.Object},System.Action{System.Object})"/> with a null instance. A null instance for a service (a callback that always returns null)
            is nearly the same as calling <see cref="M:CK.Core.SimpleServiceContainer.Remove(System.Type)"/>: any fallbacks (to a base <see cref="T:System.IServiceProvider"/> for example) can occur.
            This is stronger since this must prevent fallbacks.
            </remarks>
            <param name="serviceType">Service type to disable. It must not already exist in this container otherwise an exception is thrown.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Remove(System.Type)">
            <summary>
            Unregisters a service. Can be called even if the service does not exist.
            The service is first removed and then the OnRemove associated action is called if it exists.
            </summary>
            <param name="serviceType">Service type to unregister.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Clear">
            <summary>
            Unregisters all the services. Any "on remove" actions are executed.
            </summary>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.GetService(System.Type)">
            <summary>
            Implements <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.
            </summary>
            <param name="serviceType">Type of the service to obtain.</param>
            <returns>Built-in service, registered service, service from <see cref="P:CK.Core.SimpleServiceContainer.BaseProvider"/> or null.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.GetDirectService(System.Type)">
            <summary>
            Must return built-in services if any. These services take precedence over any registered services.
            This base implementation returns this object for <see cref="T:System.IServiceProvider"/> and <see cref="T:CK.Core.ISimpleServiceContainer"/>.
            </summary>
            <param name="serviceType">Type of the service to obtain.</param>
            <returns>A built-in service or null.</returns>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.Dispose">
            <summary>
            Disposing calls <see cref="M:CK.Core.SimpleServiceContainer.Clear"/> to unregister all services. Any "on remove" actions are executed.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleServiceContainer.DoAdd(System.Type,CK.Core.SimpleServiceContainer.ServiceEntry)">
            <summary>
            Correct ArgumentException throw by a Dictionary when adding an existing key. 
            </summary>
        </member>
        <member name="P:CK.Core.SimpleServiceContainer.BaseProvider">
            <summary>
            Gets or sets the <see cref="T:System.IServiceProvider"/> that is queried whenever a service
            is not found in this container.
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyExtension">
            <summary>
            Provides extension methods for <see cref="T:CK.Core.IReadOnlyCollection`1"/> and <see cref="T:CK.Core.IReadOnlyList`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToArray``1(CK.Core.IReadOnlyCollection{``0})">
            <summary>
            Creates an array from a read only collection.
            This is a much more efficient version than the IEnumerable ToArray extension method
            since this implementation allocates one and only one array. 
            </summary>
            <typeparam name="T">Type of the array and lists elements.</typeparam>
            <param name="list">Read only collection of elements.</param>
            <returns>A new array that contains the same element as the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains the conversion of elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a sub seqence of a <see cref="T:System.Collections.Generic.IList`1"/>.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Int32,System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a sub seqence of a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains the converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> starting at a given index.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <returns>A read only list that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.IList{``1},System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate, starting at a given index.
            It is an independant storage (a copy).
            </summary>
            <typeparam name="T">The type of the elements of out.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only list that contains converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> that is a copy of the <see cref="T:System.Collections.Generic.ICollection`1"/> content.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input collection following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``2(System.Collections.Generic.ICollection{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input collection following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyList`1"/> from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a read only list from.</param>
            <returns>A read only list that contains the elements from the input sequence following the enumeration order.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a sub seqence of a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Int32,System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a sub seqence of a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="count">Number of elements to take into account.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only collection from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <returns>A read only collection that contains the elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.IList{``1},System.Int32,System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IList`1"/> and a convertor delegate, starting at a given index.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only list.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IList`1"/> to create a read only list from.</param>
            <param name="startIndex">Starting index in source where copy must start.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains converted elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <returns>A read only collection that contains the elements from the input collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``2(System.Collections.Generic.ICollection{``1},System.Func{``1,``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of the resulting read only collection.</typeparam>
            <typeparam name="U">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.ICollection`1"/> to create a read only list from.</param>
            <param name="convertor">A function that transforms <typeparamref name="U"/> into <typeparamref name="T"/> elements.</param>
            <returns>A read only collection that contains the conversion of elements from the input sequence.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyExtension.ToReadOnlyCollection``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:CK.Core.IReadOnlyCollection`1"/> from a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">The type of the elements of source.</typeparam>
            <param name="source">A <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create a read only list from.</param>
            <returns>A read only collection that contains the elements from the input sequence following the enumeration order.</returns>
        </member>
        <member name="T:CK.Core.EnumerableExtension">
            <summary>
            Provides extension methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedStrict``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks whether the enumerable is in strict (no duplicates) ascending order (uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> Compare method).
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="source">This enumerable.</param>
            <returns>True if the enumerable is empty or is in strict ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedLarge``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks whether the enumerable is in large (duplicates allowed) ascending order (uses the <see cref="P:System.Collections.Generic.Comparer`1.Default"/> Compare method).
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="source">This enumerable.</param>
            <returns>True if the enumerable is empty or is in large ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedStrict``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Checks whether the enumerable is in strict (no duplicates) ascending order based on a comparison function.
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="source">This enumerable.</param>
            <param name="comparison">The delegate used to compare elements.</param>
            <returns>True if the enumerable is empty or is in strict ascending order.</returns>
        </member>
        <member name="M:CK.Core.EnumerableExtension.IsSortedLarge``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Checks whether the enumerable is in large (duplicates allowed) ascending order based on a comparison function.
            </summary>
            <typeparam name="T">Element type of the enumerable.</typeparam>
            <param name="source">This enumerable.</param>
            <param name="comparison">The delegate used to compare elements.</param>
            <returns>True if the enumerable is empty or is in large ascending order.</returns>
        </member>
        <member name="T:CK.Core.SimpleTypeFinder">
            <summary>
            Very simple default implementation of the <see cref="T:CK.Core.ISimpleTypeFinder"/>: it can be used as a base class.
            A static <see cref="F:CK.Core.SimpleTypeFinder.Default"/> is available.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleTypeFinder.Default">
            <summary>
            Default implementation for <see cref="T:CK.Core.ISimpleTypeFinder"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.MapType(System.String)">
            <summary>
            Default implementation returns exactly its <paramref name="assemblyQualifiedName"/> parameter.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name of a type.</param>
            <returns>The assembly qualified name to use.</returns>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.ResolveType(System.String,System.Boolean)">
            <summary>
            Simple implementation that calls <see cref="M:CK.Core.SimpleTypeFinder.MapType(System.String)"/> and then <see cref="M:System.Type.GetType(System.String,System.Boolean)"/>.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name of a type.</param>
            <param name="throwOnError">
            True to ALWAYS throw a <see cref="T:System.TypeLoadException"/> if the type is not found.
            False prevents any exception to be thrown and simply returns null.
            </param>
            <returns>The type or null if not found and <paramref name="throwOnError"/> is false.</returns>
            <exception cref="T:System.TypeLoadException">
            When <paramref name="throwOnError"/> is true, always throws this kind of exception.
            The original error (not a <see cref="T:System.TypeLoadException"/>) is available in the <see cref="P:System.Exception.InnerException"/>.
            </exception>
        </member>
        <member name="M:CK.Core.SimpleTypeFinder.SplitNames(System.String,System.String@,System.String@)">
            <summary>
            Helper method to split the assembly qualified name into its assembly name and full type name.
            </summary>
            <param name="assemblyQualifiedName">The assembly qualified name to split.</param>
            <param name="assemblyName">Assembly name on output or an empty string.</param>
            <param name="fullTypeName">Full type name on output or an empty string.</param>
            <returns>True if the split has been successfully done. False otherwise.</returns>
        </member>
        <member name="T:CK.Core.IMergeable">
            <summary>
            Simple interface to support merging of information from external objects.
            </summary>
        </member>
        <member name="M:CK.Core.IMergeable.Merge(System.Object,System.IServiceProvider)">
            <summary>
            Attempts to merge this object with the given one.
            This method should not raise any exception. Instead, false should be returned. 
            If an exception is raised, callers should handle the exception and behaves as if the method returned false.
            </summary>
            <param name="source">Source object to merge into this one.</param>
            <param name="services">Optional services (can be null) that can be injected into the merge process.</param>
            <returns>True if the merge succeeded, false if the merge failed or is not possible.</returns>
        </member>
        <member name="T:CK.Core.LogLevelFilter">
            <summary>
            Defines filters for <see cref="T:CK.Core.LogLevel"/>.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Trace">
            <summary>
            Everythnig is logged (<see cref="F:CK.Core.LogLevel.Trace"/>).
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Info">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Info"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Warn">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Warn"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Error">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Error"/> and above is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Fatal">
            <summary>
            Only <see cref="F:CK.Core.LogLevel.Fatal"/> is logged.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevelFilter.Off">
            <summary>
            Do not log anything.
            </summary>
        </member>
        <member name="T:CK.Core.R">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CK.Core.R.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CK.Core.R.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:CK.Core.R.ActionSequenceReadOnly">
            <summary>
              Looks up a localized string similar to ActionSequence is read only: no action can be appended..
            </summary>
        </member>
        <member name="P:CK.Core.R.ArgumentCountNegative">
            <summary>
              Looks up a localized string similar to Argument count can not be negative..
            </summary>
        </member>
        <member name="P:CK.Core.R.DirectServicesCanNotBeDisabled">
            <summary>
              Looks up a localized string similar to Service {0} is direcly supported by the container. It can not be disabled..
            </summary>
        </member>
        <member name="P:CK.Core.R.ExceptionWhileResolvingType">
            <summary>
              Looks up a localized string similar to An exception occured while resolving type: {0}..
            </summary>
        </member>
        <member name="P:CK.Core.R.ExpectedXmlEndElement">
            <summary>
              Looks up a localized string similar to Expected EndElement token named {0}..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceAlreadyDirectlySupported">
            <summary>
              Looks up a localized string similar to Service {0} is directly supported by the container..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceAlreadyRegistered">
            <summary>
              Looks up a localized string similar to Service {0} is already registered by the container..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceImplCallbackTypeMismatch">
            <summary>
              Looks up a localized string similar to Service {0} is not implemented by object {1} returned by the callback..
            </summary>
        </member>
        <member name="P:CK.Core.R.ServiceImplTypeMismatch">
            <summary>
              Looks up a localized string similar to Service {0} is not implemented by object {1}..
            </summary>
        </member>
        <member name="P:CK.Core.R.UnregisteredServiceInServiceProvider">
            <summary>
              Looks up a localized string similar to Unable to find service &apos;{0}&apos;..
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyListOnIList`1">
            <summary>
            Adapts a <see cref="T:System.Collections.Generic.IList`1"/> object to the <see cref="T:CK.Core.IReadOnlyList`1"/> interface.
            </summary>
            <typeparam name="T">Type of the element.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyListOnIList`1"/> around a <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <param name="list">List to wrap.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.IndexOf(System.Object)">
            <summary>
            Determines the index of a specific item in list.
            </summary>
            <param name="item">The item to locate in the list.</param>
            <returns>The index of item if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.Contains(System.Object)">
            <summary>
            Whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.NewImmutableCopy(System.Collections.Generic.IList{`0})">
            <summary>
            Obsolete, use ToReadOnlyList or ToReadOnlyCollection extension method instead.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListOnIList`1.NewImmutableCopy``1(System.Collections.Generic.IList{``0},System.Func{``0,`0})">
            <summary>
            Obsolete, use ToReadOnlyList or ToReadOnlyCollection extension method instead.
            </summary>
            <typeparam name="U"></typeparam>
            <param name="list"></param>
            <param name="convertor"></param>
            <returns></returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`1.Inner">
            <summary>
            Gets the wrapped list.
            </summary>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="i">The zero-based index of the element to get or set.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="i"/> is not a valid index in the list.</exception>
        </member>
        <member name="P:CK.Core.ReadOnlyListOnIList`1.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.INamedVersionedUniqueId">
            <summary>
            Extends <see cref="T:CK.Core.IVersionedUniqueId"/> to associate a <see cref="P:PublicName"/> descriptor.
            </summary>
        </member>
        <member name="T:CK.Core.IVersionedUniqueId">
            <summary>
            Extends <see cref="T:CK.Core.IUniqueId"/> to associate a <see cref="P:Version"/> number.
            </summary>
        </member>
        <member name="P:CK.Core.IVersionedUniqueId.Version">
            <summary>
            Gets the version number associated to this object.
            Never null: defaults to <see cref="F:CK.Core.Util.EmptyVersion"/>.
            </summary>
        </member>
        <member name="P:CK.Core.INamedVersionedUniqueId.PublicName">
            <summary>
            Gets the public name of this object. 
            Never null: defaults to <see cref="F:System.String.Empty"/>.
            </summary>
        </member>
        <member name="T:CK.Core.ChangeStatus">
            <summary>
            Defines a common change status: it captures the main kind of changes
            that an object or container can support.
            This status does not pretend to describe all and every possible changes, it is a
            trade-off between explicit, simple and well defined terms and the horrifying complexity reality.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.None">
            <summary>
            No operation occured.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.Update">
            <summary>
            Denotes the update of an object.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.Add">
            <summary>
            Denotes a new object (typically the appearing of an item in a collection).
            It should have been named 'Appear' but 'Add' is a much more common term to refer
            to object apparition in classical collection scenario.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.Delete">
            <summary>
            Denotes the suppression of an object (typically the removing of an item from a collection).
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.ContainerClear">
            <summary>
            Denotes the suppression of the content of a container object (typically the clearing of a collection): no more content exist.
            </summary>
        </member>
        <member name="F:CK.Core.ChangeStatus.ContainerUpdate">
            <summary>
            Denotes a global change in the content of container object (typically the replacement of items in a collection with items from another one).
            </summary>
        </member>
        <member name="T:CK.Core.SimpleVersionedUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.INamedVersionedUniqueId"/> interface.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleVersionedUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.INamedVersionedUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/> and <see cref="F:CK.Core.Util.EmptyVersion"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleVersionedUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.INamedVersionedUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a temporary marker.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleVersionedUniqueId.EmptyArray">
            <summary>
            Empty array of <see cref="T:CK.Core.IUniqueId"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.String,System.Version)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version object. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleVersionedUniqueId.#ctor(System.Guid,System.Version)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleVersionedUniqueId.UniqueId"/>.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
        </member>
        <member name="P:CK.Core.SimpleVersionedUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleVersionedUniqueId.Version">
            <summary>
            Gets the version of this object.
            </summary>
        </member>
        <member name="T:CK.Core.SimpleNamedVersionedUniqueId">
            <summary>
            Minimal implementation of the minimal <see cref="T:CK.Core.INamedVersionedUniqueId"/> interface.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.Empty">
            <summary>
            Empty <see cref="T:CK.Core.INamedVersionedUniqueId"/> bount to the <see cref="F:System.Guid.Empty"/>, <see cref="F:CK.Core.Util.EmptyVersion"/> and <see cref="F:System.String.Empty"/>.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.InvalidId">
            <summary>
            Gets a <see cref="T:CK.Core.INamedVersionedUniqueId"/> that must be used to denote an invalid key.
            This value MUST NOT be used for anything else than a temporary marker.
            </summary>
        </member>
        <member name="F:CK.Core.SimpleNamedVersionedUniqueId.EmptyArray">
            <summary>
            Empty array of <see cref="T:CK.Core.IUniqueId"/>.
            </summary>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.String,System.Version,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version object. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name for the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.String,System.String,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> expressed as a string.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name of the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="M:CK.Core.SimpleNamedVersionedUniqueId.#ctor(System.Guid,System.Version,System.String)">
            <summary>
            Initializes a new instance of <see cref="T:CK.Core.SimpleNamedVersionedUniqueId"/> where its <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/> is built from the string
            representation of a <see cref="T:System.Guid"/>.
            </summary>
            <param name="p"><see cref="T:System.Guid"/> for the <see cref="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId"/>.</param>
            <param name="version">Version as a string. If null, <see cref="F:CK.Core.Util.EmptyVersion"/> is used.</param>
            <param name="publicName">Public name of the object. If null, <see cref="F:System.String.Empty"/> is used.</param>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.UniqueId">
            <summary>
            Gets the unique identifier that this object represents.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.Version">
            <summary>
            Gets the version of this object.
            </summary>
        </member>
        <member name="P:CK.Core.SimpleNamedVersionedUniqueId.PublicName">
            <summary>
            Gets the public name of this object.
            </summary>
        </member>
        <member name="T:CK.Core.IActivityLogger">
            <summary>
            Simple activity logger for end user communication. This is not the same as a classical logging framework: this 
            is dedicated to capture activities in order to display it to a end user.
            </summary>
        </member>
        <member name="M:CK.Core.IActivityLogger.UnfilteredLog(CK.Core.LogLevel,System.String)">
            <summary>
            Logs a text regardless of <see cref="P:CK.Core.IActivityLogger.Filter"/> level. 
            Each call to log is considered as a line: a paragraph (or line separator) is appended
            between each text if the <paramref name="level"/> is the same as the previous one.
            See remarks.
            </summary>
            <param name="level">Log level.</param>
            <param name="text">Text to log.</param>
            <returns>This logger to enable fluent syntax.</returns>
            <remarks>
            A null <paramref name="text"/> is not logged in itself but instead breaks the current <see cref="T:CK.Core.LogLevel"/>
            (as if a different <see cref="T:CK.Core.LogLevel"/> was used).
            </remarks>
        </member>
        <member name="M:CK.Core.IActivityLogger.OpenGroup(CK.Core.LogLevel,System.String,System.Func{System.String})">
            <summary>
            Opens a log level. <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)"/> must be called in order to
            close the group, or the returned object must be disposed.
            </summary>
            <param name="level">Log level. Since we are opening a group, the current <see cref="P:CK.Core.IActivityLogger.Filter"/> is ignored.</param>
            <param name="text">Text to log (the title of the group).</param>
            <param name="getConclusionText">Optional function that will be called on group closing.</param>
            <returns>A disposable object that can be used to close the group.</returns>
            <remarks>
            A group opening is not be filtered since any subordinated logs may occur.
            It is left to the implementation to handle (or not) filtering when <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)"/> is called.
            </remarks>
        </member>
        <member name="M:CK.Core.IActivityLogger.CloseGroup(System.String)">
            <summary>
            Closes the current group level, appending an optional conclusion to the opening logged information.
            </summary>
        </member>
        <member name="P:CK.Core.IActivityLogger.Filter">
            <summary>
            Gets or sets a filter based on the log level.
            This filter applies to the currently opened group.
            </summary>
        </member>
        <member name="T:CK.Core.DefaultActivityLogger">
            <summary>
            Basic implementation of <see cref="T:CK.Core.IActivityLogger"/>. 
            Handles the groups opening/closing stack and multiplexes calls to <see cref="T:CK.Core.IDefaultActivityLoggerSink"/>.
            For more control, the nested <see cref="T:CK.Core.DefaultActivityLogger.Group"/> class may also be overriden.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.#ctor">
            <summary>
            Initializes a new <see cref="T:CK.Core.DefaultActivityLogger"/>.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Register(CK.Core.IDefaultActivityLoggerSink)">
            <summary>
            Registers an <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> to the logger collection.
            Duplicate <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> are silently ignored.
            </summary>
            <param name="l">An activity logger implementation</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Unregister(CK.Core.IDefaultActivityLoggerSink)">
            <summary>
            Unregisters the given <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> from the collection of loggers.
            Silently ignored unregistered logger.
            </summary>
            <param name="l">An activity logger implementation</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.FirstLogger``1">
            <summary>
            Gets the first <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> that is comaptible with <typeparamref name="T"/> type.
            </summary>
            <typeparam name="T">Type of the logger that must be returned.</typeparam>
            <returns>The first compatible implementation, or null if no compatible logger exists.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.FirstLogger(System.Type)">
            <summary>
            Gets the first <see cref="T:CK.Core.IDefaultActivityLoggerSink"/> that is comaptible with <paramref name="loggerType"/> type.
            </summary>
            <param name="loggerType">Type of the logger that must be returned.</param>
            <returns>The first compatible implementation, or null if no compatible logger exists.</returns>
        </member>
        <member name="F:CK.Core.DefaultActivityLogger.Empty">
            <summary>
            Empty <see cref="T:CK.Core.IActivityLogger"/>: nothing is done.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.UnfilteredLog(CK.Core.LogLevel,System.String)">
            <summary>
            Do log the text regardless of current <see cref="P:CK.Core.DefaultActivityLogger.Filter"/>.
            </summary>
            <param name="level">The log level.</param>
            <param name="text">The text to log.</param>
            <returns>This <see cref="T:CK.Core.IActivityLogger"/> to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.OpenGroup(CK.Core.LogLevel,System.String,System.Func{System.String})">
            <summary>
            Opens a <see cref="T:CK.Core.DefaultActivityLogger.Group"/> configured with the given parameters.
            </summary>
            <param name="level">The log level of the group.</param>
            <param name="text">The text associated to the opening of the log.</param>
            <param name="getConclusionText">Optional function that will be called on group closing. </param>
            <returns>The <see cref="T:CK.Core.DefaultActivityLogger.Group"/>.</returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.CloseGroup(System.String)">
            <summary>
            Closes the current <see cref="T:CK.Core.DefaultActivityLogger.Group"/>.
            </summary>
            <param name="conclusion">Text to conclude the group.</param>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.CreateGroup(CK.Core.LogLevel,System.String,System.Func{System.String})">
            <summary>
            Factory method for <see cref="T:CK.Core.DefaultActivityLogger.Group"/> (or any specialized class).
            This is may be overriden in advanced scenario where groups may support more 
            information than the default ones.
            </summary>
            <param name="level">The <see cref="P:CK.Core.DefaultActivityLogger.Group.GroupLevel"/> of the group.</param>
            <param name="text">The <see cref="P:CK.Core.DefaultActivityLogger.Group.GroupText"/>.</param>
            <param name="getConclusionText">An optional delegate to call on close to obtain a conclusion text.</param>
            <returns>A new group.</returns>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.RegisteredLoggers">
            <summary>
            Gets an enumeration of registered <see cref="T:CK.Core.IDefaultActivityLoggerSink"/>.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Filter">
            <summary>
            Gets or sets the current <see cref="T:CK.Core.LogLevelFilter"/>.
            </summary>
        </member>
        <member name="T:CK.Core.DefaultActivityLogger.Group">
            <summary>
            Groups are linked together from the current one to the very first one.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Group.#ctor(CK.Core.DefaultActivityLogger,CK.Core.LogLevel,System.String,System.Func{System.String})">
            <summary>
            Initializes a new <see cref="T:CK.Core.DefaultActivityLogger.Group"/> object.
            </summary>
            <param name="logger">The logger.</param>
            <param name="level">The <see cref="P:CK.Core.DefaultActivityLogger.Group.GroupLevel"/>.</param>
            <param name="text">The <see cref="P:CK.Core.DefaultActivityLogger.Group.GroupText"/>.</param>
            <param name="getConclusionText">The delegate to call on close to obtain a conclusion text.</param>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Group.ConsumeConclusionText">
            <summary>
            Calls <see cref="P:CK.Core.DefaultActivityLogger.Group.GetConclusionText"/> and sets it to null.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Group.Dispose">
            <summary>
            Ensures that any opened groups after this one are closed before closing this one.
            </summary>
        </member>
        <member name="M:CK.Core.DefaultActivityLogger.Group.OnGroupClose(System.String)">
            <summary>
            Called whenever a group is closing.
            Must return the actual conclusion that will be used for the group: currently combines
            the <see cref="P:CK.Core.DefaultActivityLogger.Group.GetConclusionText"/> functions and the <paramref name="externalConclusion"/>
            in one string.
            </summary>
            <param name="externalConclusion">Conclusion parameter: comes from <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)"/>. Can be null.</param>
            <returns>The final conclusion to use.</returns>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.Logger">
            <summary>
            Gets the associated logger. Null whenever this group is closed.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.OpeningFilter">
            <summary>
            Gets the <see cref="T:CK.Core.LogLevelFilter"/> that was active when the 
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.Parent">
            <summary>
            Previous group. Null if this is the first opened group.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.Depth">
            <summary>
            Depth of this group (number of parent groups).
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.GroupLevel">
            <summary>
            Log level with which this group has been opened.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.GroupText">
            <summary>
            Text with which this group has been opened.
            </summary>
        </member>
        <member name="P:CK.Core.DefaultActivityLogger.Group.GetConclusionText">
            <summary>
            Optional function that will be called on group closing. 
            </summary>
        </member>
        <member name="T:CK.Core.Util">
            <summary>
            Utility class.
            </summary>
        </member>
        <member name="M:CK.Core.Util.Log2(System.UInt32)">
            <summary>
            Compute the Log2 (logarithm base 2) of a given number.
            </summary>
            <param name="v">Integer to compute</param>
            <returns>Log2 of the given integer</returns>
        </member>
        <member name="M:CK.Core.Util.Log2ForPower2(System.UInt32)">
            <summary>
            Compute the Log2ForPower2 (logarithm base 2 power 2) of a given number.
            </summary>
            <param name="v">Integer to compute. It MUST be a power of 2.</param>
            <returns>Result</returns>
        </member>
        <member name="F:CK.Core.Util.EmptyStringArray">
            <summary>
            Gets a static empty <see cref="T:System.String"/> array.
            </summary>
        </member>
        <member name="F:CK.Core.Util.EmptyVersion">
            <summary>
            The empty version is defined as the Major.Minor.Build.Revision set to "0.0.0.0".
            </summary>
        </member>
        <member name="M:CK.Core.Util.ActionDispose(System.IDisposable)">
            <summary>
            Centralized <see cref="M:System.IDisposable.Dispose"/> action call.
            Can be safely called if <paramref name="obj"/> is null.
            </summary>
            <param name="obj">The disposable object to dispose (can be null).</param>
        </member>
        <member name="M:CK.Core.Util.ActionVoid``1(``0)">
            <summary>
            Centralized void action call for any type. 
            This method is the safest method never written. 
            It does absolutely nothing.
            </summary>
            <param name="obj">Any object.</param>
        </member>
        <member name="M:CK.Core.Util.FuncIdentity``1(``0)">
            <summary>
            Centralized identity function for any type.
            </summary>
            <typeparam name="T">Type of the function parameter and return value.</typeparam>
            <param name="value">Any value returned unchanged.</param>
            <returns>The <paramref name="value"/> provided is returned as-is.</returns>
        </member>
        <member name="T:CK.Core.ReadOnlyCollectionTypeConverter`2">
            <summary>
            Wraps a <see cref="T:CK.Core.IReadOnlyCollection`1"/> of a <typeparamref name="TOuter"/> type around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            of <typeparamref name="TInner"/> (the <see cref="P:CK.Core.ReadOnlyCollectionTypeConverter`2.Inner"/> collection).
            The converter from inner objects to outer objects is required (to expose the content). 
            An optional converter (outer to inner) enables O(1) <see cref="M:CK.Core.ReadOnlyCollectionTypeConverter`2.Contains(System.Object)"/> method if and only if the inner collection
            supports O(1) <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/> method (this is the case of dictionary Keys collection).
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of the objects contained in the <see cref="P:CK.Core.ReadOnlyCollectionTypeConverter`2.Inner"/> collection.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionTypeConverter`2.#ctor(System.Collections.Generic.ICollection{`1},System.Converter{`1,`0},System.Converter{`0,`1})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionAdapter`2"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            thanks to a <see cref="T:System.Converter`2"/> and an optional <see cref="T:System.Converter`2"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
            <param name="innerToOuter">The converter function from <typeparamref name="TInner"/> to <typeparamref name="TOuter"/>.</param>
            <param name="outerToInner">
            Optional converter from <typeparamref name="TOuter"/> to <typeparamref name="TInner"/>. 
            When null, the <see cref="M:CK.Core.ReadOnlyCollectionTypeConverter`2.Contains(System.Object)"/> method is O(n) instead of O(1) if the inner collection is an index.
            </param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionTypeConverter`2.#ctor(System.Collections.Generic.ICollection{`1},System.Converter{`1,`0})">
            <summary>
            Initializes a new <see cref="T:CK.Core.ReadOnlyCollectionAdapter`2"/> around a <see cref="T:System.Collections.Generic.ICollection`1"/>
            thanks to a <see cref="T:System.Converter`2"/>.
            </summary>
            <param name="c">Collection to wrap.</param>
            <param name="innerToOuter">The converter function from <typeparamref name="TInner"/> to <typeparamref name="TOuter"/>.</param>
        </member>
        <member name="M:CK.Core.ReadOnlyCollectionTypeConverter`2.Contains(System.Object)">
            <summary>
            Gets whether an item is contained or not.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>True if the item is contained in the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionTypeConverter`2.Inner">
            <summary>
            Wrapped <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="P:CK.Core.ReadOnlyCollectionTypeConverter`2.Count">
            <summary>
            Gets the number of items of the collection.
            </summary>
        </member>
        <member name="T:CK.Core.ReadOnlyListEmpty`1">
            <summary>
            Empty read only list.
            </summary>
            <typeparam name="T">Contained elements type.</typeparam>
        </member>
        <member name="F:CK.Core.ReadOnlyListEmpty`1.Empty">
            <summary>
            Static empty <see cref="T:CK.Core.ReadOnlyListEmpty`1"/>
            that will be used by the entire system.
            </summary>
        </member>
        <member name="M:CK.Core.ReadOnlyListEmpty`1.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:CK.Core.ReadOnlyListEmpty`1.IndexOf(System.Object)">
            <summary>
            Gets the index of the given element into the list.
            </summary>
            <param name="item">Element to find in the list</param>
            <returns>Index of the given element</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListEmpty`1.Contains(System.Object)">
            <summary>
            Gets if the given element is contained into the list.
            </summary>
            <param name="item">Element to find</param>
            <returns>False in all cases, a <see cref="T:CK.Core.ReadOnlyListEmpty`1"/> doesn't contains any elements.</returns>
        </member>
        <member name="M:CK.Core.ReadOnlyListEmpty`1.GetEnumerator">
            <summary>
            Gets the underlying enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListEmpty`1.Item(System.Int32)">
            <summary>
            Gets an element at the given index.
            </summary>
            <param name="i">index of the element to find</param>
            <returns>New <see cref="T:System.IndexOutOfRangeException"/>. 
            Because a <see cref="T:CK.Core.ReadOnlyListEmpty`1"/> doesn't contains any elements.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListEmpty`1.Count">
            <summary>
            Gets the count of the list.
            It will be 0 in all cases.
            </summary>
        </member>
        <member name="T:CK.Core.ISimpleTypeNaming">
            <summary>
            This simple interface allows to obtain names from types.
            This can be used in conjuction with <see cref="T:CK.Core.ISimpleTypeFinder"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ISimpleTypeNaming.GetTypeName(System.Type)">
            <summary>
            Gets an external type name.
            </summary>
            <param name="t">The type for which an external type name must be obtained.</param>
            <returns>
            A string that represents the given type. 
            Can default to <see cref="P:System.Type.AssemblyQualifiedName"/>.
            </returns>
        </member>
        <member name="T:CK.Core.ComponentModelExtension">
            <summary>
            Provides extension methods for system/component model interfaces.
            </summary>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.GetService``1(System.IServiceProvider,System.Boolean)">
            <summary>
            Strongly typed version of <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.
            </summary>
            <param name="source">This service provider.</param>
            <param name="throwOnNull">True to throw an exception if the service can not be provided (otherwise null is returned).</param>
            <returns>A service object of the required type or null if not found and <paramref name="throwOnNull"/> is false.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.GetService``1(System.IServiceProvider)">
            <summary>
            Strongly typed version of <see cref="M:System.IServiceProvider.GetService(System.Type)"/> that returns null if service is not found.
            (Same behavior as <see cref="M:System.IServiceProvider.GetService(System.Type)"/>.)
            </summary>
            <param name="source">This service provider.</param>
            <returns>A service object of the required type or null if not found.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Merge(CK.Core.IMergeable,System.Object)">
            <summary>
            Merges this <see cref="T:CK.Core.IMergeable"/> object without any <see cref="T:System.IServiceProvider"/>.
            This method should not raise any execption. Instead, false should be returned. 
            If an exception is raised, it must be handled as if the method returned false.
            </summary>
            <param name="this">This mergeable object.</param>
            <param name="source">The object to merge. When the object is the same as this, true is returned.</param>
            <returns>True if the merge succeeded, false if the merge failed or is not possible.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add(CK.Core.ISimpleServiceContainer,System.Type,System.Object)">
            <summary>
            Registers a service with its implementation.
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add(CK.Core.ISimpleServiceContainer,System.Type,System.Func{System.Object})">
            <summary>
            Registers a service associated to a callback.
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceType">Service type to register. It must not already exist in this container otherwise an exception is thrown.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,``0)">
            <summary>
            Type safe version to register a service implementation (type of the service is the type of the implementation).
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,``0,System.Action{``0})">
            <summary>
            Type safe version to register a service implementation (type of the service is the type of the implementation), 
            and an optional callback that will be called when the service will be removed.
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Implementation of the service. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,System.Func{``0})">
            <summary>
            Type safe version to register a service associated to a callback.
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ComponentModelExtension.Add``1(CK.Core.ISimpleServiceContainer,System.Func{``0},System.Action{``0})">
            <summary>
            Type safe version to register a service associated to a callback (and an optional callback that will be called when the service will be removed).
            The <paramref name="serviceInstance"/> is called as long as no service has been obtained (serviceInstance returns null). 
            Once the actual service has been obtained, it is kept and serviceInstance is not called anymore.
            </summary>
            <param name="c">This <see cref="T:CK.Core.ISimpleServiceContainer"/> object.</param>
            <param name="serviceInstance">Delegate to call when needed. Can not be null.</param>
            <param name="onRemove">Optional action that will be called whenever <see cref="M:CK.Core.ISimpleServiceContainer.Remove(System.Type)"/>, <see cref="M:CK.Core.ISimpleServiceContainer.Clear"/> or <see cref="M:System.IDisposable.Dispose"/>
            is called and a service as been successfuly obtained.</param>
            <returns>This object to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.ActionSequence">
            <summary>
            Implementation of <see cref="T:CK.Core.IActionSequence"/>. 
            Actions are executed when one of the <see cref="M:CK.Core.ActionSequence.Run"/> methods is called and in the order they have been added.
            An action that is executing can <see cref="M:Append"/> a new action that will be executed later
            but during the same current <see cref="M:CK.Core.ActionSequence.Run"/> call.
            </summary>
            <remarks>
            This is a low level implementation: no cycle nor call reentrancy detection are made. It is 
            up to the developper to correctly append the actions to the sequence.
            </remarks>
        </member>
        <member name="M:CK.Core.ActionSequence.Append(System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            Appends an event raising.
            </summary>
            <param name="e">The <see cref="T:System.EventHandler"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append``1(System.EventHandler{``0},System.Object,``0)">
            <summary>
            Appends an event raising.
            </summary>
            <typeparam name="T">Must be a class that inherits from <see cref="T:System.EventArgs"/>.</typeparam>
            <param name="e">The <see cref="T:System.EventHandler`1"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append(System.Action)">
            <summary>
            Appends an action (without parameters).
            </summary>
            <param name="action">No parameter <see cref="T:System.Action"/> delegate.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append``1(System.Action{``0},``0)">
            <summary>
            Appends an action (with one parameter).
            </summary>
            <param name="action">One parameter <see cref="T:System.Action"/> delegate.</param>
            <param name="parameter">Action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append``2(System.Action{``0,``1},``0,``1)">
            <summary>
            Appends an action (with two parameters).
            </summary>
            <param name="action">Two parameters <see cref="T:System.Action"/> delegate.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Append``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            Appends an action (with three parameters).
            </summary>
            <param name="action">Three parameters <see cref="T:System.Action"/> delegate.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
            <param name="p3">Third action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequence.Clear">
            <summary>
            Removes all recorded actions.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequence.Run">
            <summary>
            Invokes the sequence of actions and keep them in this sequence.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequence.RunOnce">
            <summary>
            Invokes the sequence of actions and forget them as soon as they are executed.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequence.RunOnceSafe">
            <summary>
            Invokes the sequence of actions and forget them as soon as they are executed.
            Traps any exception and continues the execution.
            </summary>
            <returns>A non empty list of exceptions if (at least) one error occured, null in no error occured.</returns>
        </member>
        <member name="P:CK.Core.ActionSequence.ReadOnly">
            <summary>
            Gets or sets a boolean that states whether this sequence is read-only. 
            When a sequence is read-only, any attempt to append an action is an error (an
            exception will be thrown).
            Defaults to false.
            </summary>
        </member>
        <member name="T:CK.Core.OSVersionInfo">
            <summary>
            Provides detailed information about the host operating system.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.ProgramBits">
            <summary>
            Determines if the current application is 32 or 64-bit.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.OSBits">
            <summary>
            Gets the <see cref="T:CK.Core.OSVersionInfo.SoftwareArchitecture"/> of the application.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.ProcessorBits">
            <summary>
            Determines if the current processor is 32 or 64-bit.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.Edition">
            <summary>
            Gets the edition of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.Name">
            <summary>
            Gets the name of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.ServicePack">
            <summary>
            Gets the service pack information of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.IsWindowsVistaOrGreater">
            <summary>
            Gets if the OS is Windows Vista or greater (like Windows 7).
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.BuildVersion">
            <summary>
            Gets the build version number of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.VersionString">
            <summary>
            Gets the full version string of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.Version">
            <summary>
            Gets the full version of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.MajorVersion">
            <summary>
            Gets the major version number of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.MinorVersion">
            <summary>
            Gets the minor version number of the operating system running on this computer.
            </summary>
        </member>
        <member name="P:CK.Core.OSVersionInfo.RevisionVersion">
            <summary>
            Gets the revision version number of the operating system running on this computer.
            </summary>
        </member>
        <member name="T:CK.Core.OSVersionInfo.SoftwareArchitecture">
            <summary>
            Underlying achitecture of the software
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.SoftwareArchitecture.Unknown">
            <summary>
            Unkown
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.SoftwareArchitecture.Bit32">
            <summary>
            32 bits
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.SoftwareArchitecture.Bit64">
            <summary>
            64 bits
            </summary>
        </member>
        <member name="T:CK.Core.OSVersionInfo.ProcessorArchitecture">
            <summary>
            Underlying achitecture of the hardware
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.ProcessorArchitecture.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.ProcessorArchitecture.Bit32">
            <summary>
            32 bits
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.ProcessorArchitecture.Bit64">
            <summary>
            64 bits
            </summary>
        </member>
        <member name="F:CK.Core.OSVersionInfo.ProcessorArchitecture.Itanium64">
            <summary>
            Itanium
            </summary>
        </member>
        <member name="T:CK.Core.Adapter">
            <summary>
            </summary>
        </member>
        <member name="M:CK.Core.Adapter.ToPredicate``1(System.Action{``0},System.Boolean)">
            <summary>
            Wraps an action in a predicate that returns always true.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="a">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <param name="result">result that will be returned</param>
            <returns>A predicate that performs the action and returns true.</returns>
        </member>
        <member name="M:CK.Core.Adapter.AlwaysTrue``1(System.Action{``0})">
            <summary>
            Wraps an action in a predicate that returns always true.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="a">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <returns>A predicate that performs the action and returns true.</returns>
        </member>
        <member name="M:CK.Core.Adapter.AlwaysFalse``1(System.Action{``0})">
            <summary>
            Wraps an action in a predicate that returns always false.
            </summary>
            <typeparam name="T">The type of the action's parameter.</typeparam>
            <param name="a">The action (a method that accepts <typeparamref name="T"/> as its only argument).</param>
            <returns>A predicate that performs the action and returns false.</returns>
        </member>
        <member name="T:CK.Core.ReadOnlyListTypeAdapter`2">
            <summary>
            Will be obsolete in .Net framework 4.0 (this is only here to support covariance).
            </summary>
            <typeparam name="TOuter">Type of the object that must be exposed.</typeparam>
            <typeparam name="TInner">Actual type of the objects contained in the <see cref="P:CK.Core.ReadOnlyListTypeAdapter`2.Inner"/> collection.</typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyListTypeAdapter`2.#ctor(System.Collections.Generic.IList{`1})">
            <summary>
            Constructor
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:CK.Core.ReadOnlyListTypeAdapter`2.IndexOf(System.Object)">
            <summary>
            Gets an item index.
            </summary>
            <param name="item">Item to challenge.</param>
            <returns>-1 if the item is not contained in the collection.</returns>
        </member>
        <member name="P:CK.Core.ReadOnlyListTypeAdapter`2.Inner">
            <summary>
            Wrapped list.
            </summary>
        </member>
        <member name="P:CK.Core.ReadOnlyListTypeAdapter`2.Item(System.Int32)">
            <summary>
            Gets the element by index.
            </summary>
            <param name="i">Index of the element.</param>
            <returns>The element at index i.</returns>
        </member>
        <member name="T:CK.Core.ReadOnlyListAdapter`2">
            <summary>
            Obsolete, use <see cref="T:CK.Core.ReadOnlyListTypeAdapter`2"/> instead.
            </summary>
            <typeparam name="TOuter"></typeparam>
            <typeparam name="TInner"></typeparam>
        </member>
        <member name="M:CK.Core.ReadOnlyListAdapter`2.#ctor(System.Collections.Generic.IList{`1})">
            <summary>
            Constructor
            </summary>
            <param name="c"></param>
        </member>
        <member name="T:CK.Core.TemporaryFile">
            <summary>
            Small helper to automatically delete a temporary file. 
            It is mainly a secure wrapper around <see cref="M:System.IO.Path.GetTempFileName">GetTempFileName</see> that 
            creates a uniquely named, zero-byte temporary file on disk and returns the full path of that file: the <see cref="P:Path"/>
            property exposes it.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/>.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.Boolean)">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/>.
            When <paramref name="shortLived"/> is true, the <see cref="F:System.IO.FileAttributes.Temporary"/> is set on the file.
            </summary>
            <param name="shortLived">True to set the <see cref="F:System.IO.FileAttributes.Temporary"/> on the file.</param>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.String)">
            <summary>
            Initializes the TemporaryFile with an extension - the file will have a name looking like : xxxx.tmp.extension        
            </summary>
            <param name="extension">The extension of the file (example : '.png' and 'png' would both work) </param>
        </member>
        <member name="M:CK.Core.TemporaryFile.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new short lived <see cref="T:CK.Core.TemporaryFile"/> with an extension.
            When <paramref name="shortLived"/> is true, the <see cref="F:System.IO.FileAttributes.Temporary"/> is set on the file.
            The file will have a name looking like : xxxx.tmp.extension
            </summary>
            <param name="shortLived">True to set the <see cref="F:System.IO.FileAttributes.Temporary"/> on the file.</param>
            <param name="extension">The extension of the file (example : '.png' and 'png' would both work)</param>
        </member>
        <member name="M:CK.Core.TemporaryFile.Finalize">
            <summary>
            Finalizer attempts to delete the file.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.Detach">
            <summary>
            Detachs the temporary file: it will no more be automatically destroyed.
            </summary>
        </member>
        <member name="M:CK.Core.TemporaryFile.Dispose">
            <summary>
            Attempts to delete the temporary file.
            </summary>
        </member>
        <member name="P:CK.Core.TemporaryFile.Path">
            <summary>
            Gets the complete file path of the temporary file.
            The file is not opened but exists, initiall
            </summary>
        </member>
        <member name="T:CK.Core.LogLevel">
            <summary>
            Five standard log levels in increasing order used by <see cref="T:CK.Core.IActivityLogger"/>.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Trace">
            <summary>
            A trace logging level (the most verbose level).
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Info">
            <summary>
            An info logging level.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Warn">
            <summary>
            A warn logging level.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Error">
            <summary>
            An error logging level: denotes an error for the current activity. 
            This error does not necessarily abort the activity.
            </summary>
        </member>
        <member name="F:CK.Core.LogLevel.Fatal">
            <summary>
            A fatal error logging level: denotes an error that breaks (aborts)
            the current activity. This kind of error may have important side effects
            on the system.
            </summary>
        </member>
        <member name="T:CK.Core.ActivityLoggerExtension">
            <summary>
            Provides extension methods for <see cref="T:CK.Core.IActivityLogger"/>.
            </summary>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.OpenGroup(CK.Core.IActivityLogger,CK.Core.LogLevel,System.String)">
            <summary>
            Opens a log level. <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)">CloseGroup</see> must be called in order to
            close the group, or the returned object must be disposed.
            </summary>
            <param name="l">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="level">Log level. Since we are opening a group, the current <see cref="P:CK.Core.IActivityLogger.Filter">Filter</see> is ignored.</param>
            <param name="text">Text to log (the title of the group).</param>
            <returns>A disposable object that can be used to close the group.</returns>
            <remarks>
            A group opening is not be filtered since any subordinated logs may occur.
            It is left to the implementation to handle (or not) filtering when <see cref="M:CK.Core.IActivityLogger.CloseGroup(System.String)">CloseGroup</see> is called.
            </remarks>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as a trace.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a trace.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a trace.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a trace.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a trace.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Trace``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Trace"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as an info.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an info.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an info.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an info.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an info.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Info``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Info"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as a warning.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a warning.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a warning.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a warning.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a warning.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Warn``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Warn"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as an error.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an error.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an error.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an error.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as an error.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Error``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Error"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String)">
            <summary>
            Logs the text if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Text to log as a fatal error.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String,System.Object)">
            <summary>
            Logs a formatted text with one placeholder/parameter if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a fatal error.</param>
            <param name="arg0">Parameter to format (placeholder {0}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String,System.Object,System.Object)">
            <summary>
            Logs a formatted text with two placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a fatal error.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String,System.Object,System.Object,System.Object)">
            <summary>
            Logs a formatted text with three placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a fatal error.</param>
            <param name="arg0">First parameter to format (placeholder {0}).</param>
            <param name="arg1">Second parameter to format (placeholder {1}).</param>
            <param name="arg2">Third parameter to format (placeholder {2}).</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.String,System.Object[])">
            <summary>
            Logs a formatted text with placeholders/parameters if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="format">Text format to log as a fatal error.</param>
            <param name="args">Multiple parameters to format.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal(CK.Core.IActivityLogger,System.Func{System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal``1(CK.Core.IActivityLogger,``0,System.Func{``0,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <typeparam name="T">Type of the parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param">Parameter of the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="M:CK.Core.ActivityLoggerExtension.Fatal``2(CK.Core.IActivityLogger,``0,``1,System.Func{``0,``1,System.String})">
            <summary>
            Logs a formatted text by calling a delegate if current <see cref="P:CK.Core.IActivityLogger.Filter"/> is <see cref="F:CK.Core.LogLevel.Fatal"/> or above.
            </summary>
            <typeparam name="T1">Type of the first parameter that <paramref name="text"/> accepts.</typeparam>
            <typeparam name="T2">Type of the second parameter that <paramref name="text"/> accepts.</typeparam>
            <param name="a">This <see cref="T:CK.Core.IActivityLogger"/> object.</param>
            <param name="param1">First parameter for the <paramref name="text"/> delegate.</param>
            <param name="param2">Second parameter for the <paramref name="text"/> delegate.</param>
            <param name="text">Delegate that returns a string.</param>
            <returns>This logger to enable fluent syntax.</returns>
        </member>
        <member name="T:CK.Core.IDefaultActivityLoggerSink">
            <summary>
            Simple activity logger implementation for <see cref="T:CK.Core.DefaultActivityLogger"/>.
            Inherits from this interface to implement your own logger (ie: XmlLogger).
            Each method described below provides an easy way to react to <see cref="T:CK.Core.IActivityLogger"/> calls.
            </summary>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnEnterLevel(CK.Core.LogLevel,System.String)">
            <summary>
            Called for the first text of a <see cref="T:CK.Core.LogLevel"/>.
            </summary>
            <param name="level">The new current log level.</param>
            <param name="text">Text to start.</param>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnContinueOnSameLevel(CK.Core.LogLevel,System.String)">
            <summary>
            Called for text with the same <see cref="T:CK.Core.LogLevel"/> as the previous ones.
            </summary>
            <param name="level">The current log level.</param>
            <param name="text">Text to append.</param>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnLeaveLevel(CK.Core.LogLevel)">
            <summary>
            Called when current log level changes.
            </summary>
            <param name="level">The previous log level.</param>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnGroupOpen(CK.Core.DefaultActivityLogger.Group)">
            <summary>
            Called whenever a group is opened.
            </summary>
            <param name="g">The newly opened group.</param>
        </member>
        <member name="M:CK.Core.IDefaultActivityLoggerSink.OnGroupClose(CK.Core.DefaultActivityLogger.Group,System.String)">
            <summary>
            Called whenever a group is closed.
            </summary>
            <param name="g">The closing group.</param>
            <param name="conclusion">Conclusion text.</param>
        </member>
        <member name="T:CK.Core.ActionSequenceExtension">
            <summary>
            Holds extensions methods of <see cref="T:CK.Core.IActionSequence"/> interface.
            </summary>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater(CK.Core.IActionSequence,System.Action)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append(System.Action)">Appends</see> the action to this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="action">The action to execute. Can be null: in such case nothing is done.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater``1(CK.Core.IActionSequence,System.Action{``0},``0)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append``1(System.Action{``0},``0)">Appends</see> the action to this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="p">Parameter of the action.</param>
            <param name="action">The action to execute. Can be null: in such case nothing is done.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater``2(CK.Core.IActionSequence,System.Action{``0,``1},``0,``1)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append``2(System.Action{``0,``1},``0,``1)">Appends</see> the action to this <see cref="T:CK.Core.IActionSequence"/> if possible, 
            or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="action">The action to execute. Can be null: in such case nothing is done.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater``3(CK.Core.IActionSequence,System.Action{``0,``1,``2},``0,``1,``2)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append``3(System.Action{``0,``1,``2},``0,``1,``2)">Appends</see> the action to 
            this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="action">The action to execute. Can be null: in such case nothing is done.</param>
            <param name="p1">First action parameter.</param>
            <param name="p2">Second action parameter.</param>
            <param name="p3">Third action parameter.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater(CK.Core.IActionSequence,System.EventHandler,System.Object,System.EventArgs)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append(System.EventHandler,System.Object,System.EventArgs)">Appends</see> an event raising to this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="e">The <see cref="T:System.EventHandler"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="M:CK.Core.ActionSequenceExtension.NowOrLater``1(CK.Core.IActionSequence,System.EventHandler{``0},System.Object,``0)">
            <summary>
            <see cref="M:CK.Core.IActionSequence.Append``1(System.EventHandler{``0},System.Object,``0)">Appends</see> an event raising to this <see cref="T:CK.Core.IActionSequence"/> if possible, or executes it immediately.
            </summary>
            <typeparam name="T">Must be a class that inherits from <see cref="T:System.EventArgs"/>.</typeparam>
            <param name="s">This <see cref="T:CK.Core.IActionSequence"/>. Can be null.</param>
            <param name="e">The <see cref="T:System.EventHandler`1"/> delegate.</param>
            <param name="source">Source of the event.</param>
            <param name="eventArgs">Event argument.</param>
        </member>
        <member name="T:CK.Core.EnumEmpty`1">
            <summary>
            Defines a unique empty enumerator.
            </summary>
        </member>
        <member name="F:CK.Core.EnumEmpty`1.Empty">
            <summary>
            Gets the default <see cref="T:CK.Core.EnumEmpty`1"/>.
            This field is static readonly and is thread safe by design.
            </summary>
        </member>
        <member name="M:CK.Core.EnumEmpty`1.Dispose">
            <summary>
            Dispose the enumerator.
            </summary>
        </member>
        <member name="M:CK.Core.EnumEmpty`1.MoveNext">
            <summary>
            Move to the next element of the enumerator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CK.Core.EnumEmpty`1.Reset">
            <summary>
            Reset the enumerator.
            </summary>
        </member>
        <member name="P:CK.Core.EnumEmpty`1.Current">
            <summary>
            Gets the current element.
            </summary>
        </member>
    </members>
</doc>
