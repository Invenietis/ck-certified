<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CK.Windows.Core</name>
    </assembly>
    <members>
        <member name="T:CK.Windows.SimpleCommand">
            <summary>
            A command whose sole purpose is to relay its functionality to other
            objects by invoking delegates. The default return value for the CanExecute method is 'true'.
            From http://mvvmfoundation.codeplex.com/ open source project.
            </summary>
            <remarks>
            CanExecuteChanged and memory leaks.
            <para>
            This class uses the centralized <see cref="E:System.Windows.Input.CommandManager.RequerySuggested"/> to implement <see cref="E:CK.Windows.SimpleCommand.CanExecuteChanged"/> event
            when a <see cref="M:CK.Windows.SimpleCommand.CanExecute(System.Object)"/> delegate is provided.
            </para>
            <para>
            Apparently, WPF expects this event to be implemented as a weak event. That means, the event should use a List&lt;WeakReference&gt; for 
            the delegates, so that objects don’t have to unregister (because they don’t!).
            </para>
            <para>
            Interestingly, this means a WeakReference to the delegate, not to the listening object – the listening object 
            must keep a reference to its own delegate instance so that the delegate doesn’t get garbage collected even 
            though the listening object is still reachable.
            CommandManager.RequerySuggested is such a weak event, so code below works fine.
            </para>
            The default interface implementation generated by VS – a default C# event (“public EventHandler CanExecuteChanged;”) – will cause a memory leak!
            So basically, there are only two easy options:
            <list type="">
            <item>
            If CanExecute never changes and you don’t intend to fire the event, then don’t use a default event, use an event that doesn’t store the delegates.
            <c>public event EventHandler CanExecuteChanged { add { } remove { } }</c>
            </item>
            <item>2) If CanExecute changes, use the CommandManager.</item>
            </list>
            </remarks>
        </member>
        <member name="M:CK.Windows.SimpleCommand.#ctor(System.Action)">
            <summary>
            Creates a new command that can always execute.
            </summary>
            <param name="execute">The execution logic.</param>
        </member>
        <member name="M:CK.Windows.SimpleCommand.#ctor(System.Action,System.Func{System.Boolean})">
            <summary>
            Creates a new command.
            </summary>
            <param name="execute">The execution logic.</param>
            <param name="canExecute">The execution status logic.</param>
        </member>
        <member name="T:CK.Windows.SimpleCommand`1">
            <summary>
            A command whose sole purpose is to relay its functionality to other
            objects by invoking delegates. The default return value for the CanExecute method is 'true'.
            From http://mvvmfoundation.codeplex.com/ open source project.
            </summary>
        </member>
        <member name="M:CK.Windows.SimpleCommand`1.#ctor(System.Action{`0},System.Func{`0,System.Boolean})">
            <summary>
            Creates a new command.
            </summary>
            <param name="execute">The execution logic.</param>
            <param name="canExecute">The execution status logic.</param>
        </member>
        <member name="T:CK.Windows.TypeExtension">
            <summary>
            Replacement for the standard <see cref="T:System.Windows.Markup.TypeExtension"/> to support generic types
            definition in markup (currently up to 5 type arguments are supported).
            </summary>
        </member>
        <member name="T:CK.Windows.TemplatedDataTemplateSelector">
            <summary>
            A <see cref="T:System.Windows.Controls.DataTemplateSelector"/> with an actual <see cref="T:System.Windows.DataTemplate"/> instance expressed as a XAML content property.
            By default, this child <see cref="P:CK.Windows.TemplatedDataTemplateSelector.Template"/> is always selected by <see cref="M:CK.Windows.TemplatedDataTemplateSelector.SelectTemplate(System.Object,System.Windows.DependencyObject)"/>, but the goal of this class
            is to be used as a base class: the virtual <see cref="M:CK.Windows.TemplatedDataTemplateSelector.Match(System.Object,System.Windows.DependencyObject)"/> method must be overriden.
            </summary>
        </member>
        <member name="M:CK.Windows.TemplatedDataTemplateSelector.SelectTemplate(System.Object,System.Windows.DependencyObject)">
            <summary>
            Overriden to return <see cref="P:CK.Windows.TemplatedDataTemplateSelector.Template"/> if <see cref="M:CK.Windows.TemplatedDataTemplateSelector.Match(System.Object,System.Windows.DependencyObject)"/> returns true.
            </summary>
            <param name="item">The data object for which to select the template.</param>
            <param name="container">The data-bound object.</param>
            <returns>Returns <see cref="P:CK.Windows.TemplatedDataTemplateSelector.Template"/> or null. The default value is <see cref="P:CK.Windows.TemplatedDataTemplateSelector.Template"/> since this <see cref="M:CK.Windows.TemplatedDataTemplateSelector.Match(System.Object,System.Windows.DependencyObject)"/> returns true.</returns>
        </member>
        <member name="M:CK.Windows.TemplatedDataTemplateSelector.Match(System.Object,System.Windows.DependencyObject)">
            <summary>
            Template method to be overriden.
            </summary>
            <param name="item">The data object for which to select the template.</param>
            <param name="container">The data-bound object.</param>
            <returns>True if the data object matches any constraint that this selector may implement.</returns>
        </member>
        <member name="P:CK.Windows.TemplatedDataTemplateSelector.Template">
            <summary>
            Gets or sets the actual <see cref="T:System.Windows.DataTemplate"/> that must be selected.
            </summary>
        </member>
        <member name="M:CK.Windows.BooleanToVisibilityConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Converts a boolean value to a Visibility value.
            </summary>
            <param name="value"></param>
            <param name="targetType"></param>
            <param name="parameter">
            ConverterParameter is of type Visibility
            </param><param name="culture"></param>
            <returns></returns>
        </member>
        <member name="M:CK.Windows.BooleanToVisibilityConverter.ConvertBack(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)">
            <summary>
            Supports 2-way databinding of the BooleanToVisibilityConverter, converting Visibility to a boolean.
            </summary>
            <param name="value"></param>
            <param name="targetType"></param>
            <param name="parameter"></param>
            <param name="culture"></param>
            <returns></returns>
        </member>
        <member name="M:CK.Windows.BooleanToVisibilityConverter.ParseParameter(System.Object)">
            <summary>   
            Parses 'Invert', 'Hidden' or 'Invert,Hidden' into <see cref="T:CK.Windows.BooleanToVisibilityConverter.Parameter"/>.
            </summary>   
            <param name="parameter">Parameter string.</param>   
            <returns>Parsed structure.</returns>   
        </member>
        <member name="T:CK.Windows.BooleanToVisibilityConverter.Parameter">
            <summary>
            Internal arsed data structure.
            </summary>
        </member>
        <member name="T:CK.Windows.CompositeDataTemplateSelector">
            <summary>
            This specialized <see cref="T:System.Windows.Controls.DataTemplateSelector"/> implements a simple first-match rule mechanism
            to select the <see cref="T:System.Windows.DataTemplate"/> that must be applied to an object.
            </summary>
        </member>
        <member name="M:CK.Windows.CompositeDataTemplateSelector.SelectTemplate(System.Object,System.Windows.DependencyObject)">
            <summary>
            Implements the template selection by finding the first selector among <see cref="P:CK.Windows.CompositeDataTemplateSelector.Selectors"/> that returns a non null <see cref="T:System.Windows.DataTemplate"/>.
            </summary>
            <param name="item">The object.</param>
            <param name="container"></param>
            <returns>A <see cref="T:System.Windows.DataTemplate"/> for the <paramref name="item"/>.</returns>
        </member>
        <member name="P:CK.Windows.CompositeDataTemplateSelector.Fallback">
            <summary>
            Gets the CompositeDataTemplateSelector on which we have to look for selectors if we don't find a good one in our <see pref="Selectors"/>.
            </summary>
        </member>
        <member name="P:CK.Windows.CompositeDataTemplateSelector.Selectors">
            <summary>
            Gets the list of <see cref="T:System.Windows.Controls.DataTemplateSelector"/> that this composite contains.
            </summary>
        </member>
        <member name="T:CK.Windows.DependencyObjectExtensions">
            <summary>
            Exposes useful extension methods for <see cref="T:System.Windows.DependencyObject"/>.
            </summary>
        </member>
        <member name="M:CK.Windows.DependencyObjectExtensions.FindParent(System.Windows.DependencyObject,System.Predicate{System.Windows.DependencyObject})">
            <summary>
            Gets the closest parent that matches a predicate. 
            This method correctly handles ContentElement that are not Visual nor Visual3D. 
            Extracted from http://www.codeproject.com/KB/WPF/WpfElementTrees.aspx.
            See also http://blogs.msdn.com/b/mikehillberg/archive/2008/05/23/of-logical-and-visual-trees-in-wpf.aspx about
            lagical and visual elements.
            </summary>
            <param name="this">This dependency object.</param>
            <param name="finder">Predicate to select the parent.</param>
            <returns>The first <see cref="T:System.Windows.DependencyObject"/> that satisfies the predicate. Null otherwise.</returns>
        </member>
        <member name="M:CK.Windows.DependencyObjectExtensions.FindParent``1(System.Windows.DependencyObject)">
            <summary>
            Gets the closest parent object of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">Type of parent to locate.</typeparam>
            <param name="this">This dependency object.</param>
            <returns>The first <see cref="T:System.Windows.DependencyObject"/> that is a <typeparamref name="T"/>. Null if no such parent exists.</returns>
        </member>
        <member name="T:CK.Windows.TypeDataTemplateSelector">
            <summary>
            This is a <see cref="T:CK.Windows.TemplatedDataTemplateSelector"/> that matches the <see cref="P:Type"/> of the object
            for which a data template must be selected.
            </summary>
        </member>
        <member name="P:CK.Windows.TypeDataTemplateSelector.Type">
            <summary>
            Gets or sets the type of the object that must match.
            </summary>
        </member>
        <member name="P:CK.Windows.TypeDataTemplateSelector.ExactTypeMatch">
            <summary>
            Gets or sets whether the match must be strict (i.e. <see cref="!:Type.IsAssignableFrom"/>), or
            must use more relaxed <see cref="M:CK.Reflection.ReflectionHelper.CovariantMatch(System.Type,System.Type)">covariance rules</see>.
            Defaults to false.
            </summary>
        </member>
    </members>
</doc>
